const SparsitySmall = 100.0; //10.415;
//==============================================================================
//==============================================================================
//
//		Base weapon for all D4D 
//
//==============================================================================
//==============================================================================
Class Doom4Weapon : Weapon
{
	const GrenadeOverlay = 50;
	const GrenadePrimer = 51;
	const PunchOverlay = 52;
	const PunchSway = 53;
	const WeaponSwitcher = 11;
	
	private int AlertTimer;
	int AlertTimerStart;
	
	transient Cvar WeaponMode;
	D4DHandler Event;
	MCHandler MC;
	Inventory Modules[2];
	Inventory ActiveMod;
	Array<MCBeam> Beams;
	
	meta Name CvarMode, CvarOn, CvarOff;
	meta bool MultiplayerWeapon;
	
	Property MultiplayerWeapon: MultiplayerWeapon;
	Property CvarMode: CvarMode, CvarOn, CvarOff;
	Property AlertTimerStart: AlertTimerStart;
	Default 
	{
		Doom4Weapon.AlertTimerStart 35;
		Doom4Weapon.CvarMode '', '', '';
		Doom4Weapon.MultiplayerWeapon false;
		+INVENTORY.UNDROPPABLE
		+INVENTORY.UNTOSSABLE
		+WEAPON.NODEATHINPUT
		+DONTGIB
		Weapon.BobStyle "Alpha";
		Weapon.BobSpeed 2.0;
		Weapon.BobRangeX 0.7;
		Weapon.BobRangeY 0.5;
		Weapon.UpSound "Doom4/Weapons/WeaponSwitch";
		Inventory.PickupSound "Doom4/Other/WeaponPickup";
		Inventory.RespawnTics 175;
		Tag "REPLACE ME!";
	}
	
	override void BeginPlay()
	{
		Super.BeginPlay();
		EnableAmmoSpawn();
	}
	
	override void Travelled()
	{
		Super.Travelled();
		EnableAmmoSpawn();
	}
	
	
	
	//==========================================================================
	//
	//==========================================================================
	
	override void DoEffect()
	{
		if (Owner && AlertTimer > 0)
			AlertTimer--;
	}
	
	action void AlertMonsters()
	{
		let i = invoker;
		if (i.AlertTimer < 1)
		{
			A_AlertMonsters();
			i.AlertTimer = i.AlertTimerStart;
		}
	}
	
	action void FetchWeaponMode()
	{
		let i = invoker;
		if (i.CvarMode == '')	return;
		i.WeaponMode = Cvar.GetCvar(i.CvarMode, i.owner.player);
	}
	
	action int CheckWeaponMode()
	{
		let i = invoker;
		if (!i.WeaponMode)	FetchWeaponMode();
		return i.WeaponMode ? i.WeaponMode.GetInt() : 0;
	}
	
	action void DisplayWeaponMode(bool enabled = true)
	{
		D4Msg.ClearMsg(101);
		return;
		/*
		let i = invoker;
		int id = 101;
		if (!i.WeaponMode)	
		{ 
			FetchWeaponMode();	
			if (!i.WeaponMode)	enabled = false; 
		}
		
		if (!enabled)
		{
			D4Msg.ClearMsg(id);
			return;
		}
		String text = CheckWeaponMode() ? i.CvarOn : i.CvarOff;
		D4Msg.PlainMsg("smallfont", text, (790.0, 573.0), (800, 600), color: Font.CR_WHITE, time: (0,-1,0), id: id);
		*/
	}
	
	action void ToggleWeaponMode()
	{
		let i = invoker;
		if (!i.WeaponMode)	FetchWeaponMode();
		if (i.WeaponMode)	
		{
			bool opposite = !i.WeaponMode.GetBool();
			i.WeaponMode.SetBool(opposite);
			String text = opposite ? i.CvarOn : i.CvarOff;
			D4Msg.PlainMsg("smallfont", text, (300, 420), (600, 450), color: Font.CR_ORANGE, time: (0,1.5,1), id: 112);
		}
		else Console.Printf("Cvar not found!");
	}
	
	protected action bool CheckInput(int btn, bool single = true)
	{
		if (single)	
			return (GetPlayerInput(MODINPUT_BUTTONS) & btn);
		
		return (GetPlayerInput(MODINPUT_BUTTONS) & btn) &&
				!(GetPlayerInput(MODINPUT_OLDBUTTONS) & btn);
	}
	
	//==========================================================================
	//
	//==========================================================================
	
	action Actor GetPlayerTarget()
	{
		FTranslatedLineTarget t;
		let o = invoker.owner;
		if (!o)	return null;
		
		BulletSlope(t, ALF_PORTALRESTRICT);
		return t.linetarget;
	}
	
	// Primarily used for the Chainsaw, BFG and Crucible. For most weapons this
	// is meant to do nothing, but those three enable their special ammo type
	// spawning specifically.
	virtual void EnableAmmoSpawn() { }
	
	// Gets the player preference for performing secondary priming or not.
	// Defaults to performing the secondary priming if the owner's not a player
	// or the cvar isn't found.
	action bool DoSecondaryPriming()
	{
		let plr = invoker.owner.player;
		
		// Voodoo doll check.
		if (!plr || !plr.mo || plr.mo != invoker.owner)
			return true;
			
		CVar check = CVar.GetCVar("D4D_SecondaryPriming", plr);
		return (!check || check.GetBool());
	}
	
	// Default offsets are 10.0, 4.1, -2.7
	action void A_StartBeam(
		Class<MCBeam> BeamName, Vector3 Off = (0,0,0), int Count = 1,
		Class<Actor> PuffName = "D4BulletPuff", int dmg = 0, double ang = 0, double pit = 0,
		double dist = 8192)
	{
		Count = Max(1, Count);
		
		Vector3 x, y, z, origin;
		[x, y, z] = MC_CoordUtil.GetAxes(Pitch,Angle,Roll);
		origin = Vec2OffsetZ(0,0,player.viewz) + Off.x * x + Off.y * y + Off.z * z;
		
		if (dist <= 0.0)	dist = 8192.0;
		Actor Puff = LineAttack(angle + ang, dist, pitch + pit, dmg, 'None', PuffName, LAF_NOINTERACT);
		for (int i = 0; i < Count; i++)
		{
			let Beam = MCBeam(Spawn(beamname,origin));
			Beam.Target = invoker.owner;
			Beam.Master = invoker.owner;
			Beam.Tracer = Puff;
			Beam.Angle = Angle;
			Beam.Pitch = Pitch;
			Beam.OffX = Off.x;
			Beam.OffY = Off.y;
			Beam.OffZ = Off.z;
			invoker.Beams.Push(Beam);
		}
	}
	
	action void A_UpdateBeamTracer(
		Class<Actor> PuffName = "D4BulletPuff", int dmg = 0, double ang = 0, double pit = 0,
		double dist = 8192)
	{
		int flags = LAF_NORANDOMPUFFZ;
		if (dmg <= 0)	flags |= LAF_NOINTERACT;
		Actor Puff = LineAttack(angle + ang, dist, BulletSlope() + pit, dmg, '', PuffName, flags);
		
		if (invoker.Beams.Size() < 1)	return;
		for (int i = 0; i < invoker.Beams.Size(); i++)
		{
			let mo = invoker.Beams[i];
			if (!mo)	continue;
			
			if (Puff)	mo.Tracer = Puff;
		}
	}
	
	action void A_StopBeam(Sound StopSound = "")
	{
		if (invoker.beams.Size() > 0)
		{
			A_StopSound(CHAN_WEAPON);	// Needed in the event StopSound is blank.
			A_PlaySound(StopSound, CHAN_WEAPON);	//This won't do anything if StopSound is blank.
			for (int i = 0; i < invoker.beams.Size(); i++)
			{
				let mo = invoker.Beams[i];
				if (mo)	mo.Die(null, null);
			}
			invoker.Beams.Clear();
		}
	}
	
	bool CheckInfiniteAmmo()
	{
		return (sv_infiniteammo || 
				(Owner && Owner.FindInventory('PowerInfiniteAmmo', true) != null));
	}
	
	action bool A_CheckInfiniteAmmo()
	{
		return invoker.CheckInfiniteAmmo();
	}
	
	override bool CheckAmmo(int firemode, bool autoswitch, bool requireAmmo, int ammocount)
	{
		if (ammocount == 0 || A_CheckInfiniteAmmo())
			return true;
		else if (ammocount < 0)
			return Super.CheckAmmo(firemode, autoswitch, requireammo);
		
		int temp = AmmoUse1;
		AmmoUse1 = ammocount;
		bool check = Super.CheckAmmo(firemode, autoswitch, requireammo, ammocount);
		AmmoUse1 = temp;
		return check;
	}
	
	action int DoubleSpeed()
	{	return (invoker.owner.FindInventory("PowerDoubleFiringSpeed", true) != null) ? 2 : 1;	}
	
	action bool IsDoubleSpeed()
	{	return (invoker.owner.FindInventory("PowerDoubleFiringSpeed", true) != null);	}
	
	static bool IsDoubleSpeedGlobal(Actor mo)
	{	return (mo && mo.FindInventory("PowerDoubleFiringSpeed", true));	}
	
	action Actor FireProjectile(Class<Actor> proj, Vector3 off, bool useammo = true)
	{
		let o = invoker.owner;
		Vector3 px, py, pz, origin;
		[px, py, pz] = MC_CoordUtil.GetAxes(Pitch,Angle,Roll);
		origin = Vec2OffsetZ(0,0,player.viewz) + off.x * px + off.y * py + off.z * pz;
		if (useammo)	A_FireProjectile("Nothing",0,true);
		let gren = Spawn(proj, origin, ALLOW_REPLACE);
		if (gren)
		{
			gren.target = o;
			gren.angle = o.angle;
			gren.pitch = o.pitch;
			if (gren.speed > 0)
				gren.Vel3DFromAngle(gren.speed, o.angle, o.pitch);
		}
		return gren;
	}
	
	override void OwnerDied()
	{
		A_StopBeam();
		Super.OwnerDied();
	}
	override void DetachFromOwner()
	{
		A_StopBeam();
		Super.DetachFromOwner();
	}
	override void OnDestroy()
	{
		A_StopBeam();
		Super.OnDestroy();
	}
	
	//--------------------------------------------------------------------------
	// Enables the ability to switch away from a weapon regardless of action
	// taken. Use with caution.
	//--------------------------------------------------------------------------
	action void A_SetAlwaysSwitchable(bool on)
	{
		if (!player || !on)	A_Overlay(WeaponSwitcher, "Null");	
		else				A_Overlay(WeaponSwitcher, "Overlay.SwitchOn");
	}
	
	States
	{
	Spawn:
		TNT1 A 1;
		Stop;
	Overlay.SwitchOn:
		TNT1 A 1
		{
			// Don't run this if there's no player.
			if (!player)	return ResolveState("Null");				
			
			// Every tic, this is reset to false so it needs to be constantly 
			// set back to true in order to allow this effect to happen.
			DoReadyWeaponToSwitch(player, true);
			return ResolveState(null);
		}
		Wait;
	Pickup:			// No longer used - this was only for the old SBARINFO.
		TNT1 A 0; //ACS_NamedExecuteAlways("UpdateWeaponList",0,0,0,0);
		Stop;
	//--------------------------------------------------------------
	//	Quick melee / Glory kill
	//--------------------------------------------------------------
	User2:
		---- A 0 //before it does the regular punch, it checks if the Monster; is ready to be GK'd and if GK is ON
		{
			A_GiveInventory("BusyToken");
			
			if(countinv("FinisherToken",AAPTR_PLAYER_GETTARGET)>=1 && GetCvar("D4D_ExecutionAnimation")==1 && A_CheckLOF("Null",CLOFF_SETTARGET|CLOFF_NOAIM_VERT|CLOFF_IGNOREGHOST|CLOFF_MUSTBESOLID ,100))
			{ return ResolveState("ExecuteExecutions");	}

			return ResolveState(null);
		}
		
		---- AA 1 A_WeaponOffset(16,24,WOF_ADD);	//lowers weapon	
		---- A 15 A_Overlay(PunchOverlay,"Overlay.Puncher");	//calls the punching hand
		---- AAA 1 A_WeaponOffset(-11,-16,WOF_ADD);
		---- A 0 
		{ 
			A_SetInventory("BusyToken",0);
			return ResolveState("Ready"); 
		}
		
	Overlay.Puncher:
		MELE A 0 
		{
			A_OverlayFlags(PunchOverlay,PSPF_ADDWEAPON,0);
		}
		MELE F 1 A_OverlayOffset(PunchOverlay,0,40);
		---- A 0 A_Overlay(PunchSway,"Overlay.PunchSwayEffect");	//calls the punching swaying
		MELE F 4 
		{
			A_OverlayOffset(PunchOverlay,10,32);
			
			if(countinv("FinisherToken",AAPTR_PLAYER_GETTARGET)>=1)
			{
				A_CustomPunch(999999,1,0,"MeleePunchPuff",80,0,0,null,"Doom4/Weapon/Melee/Punch","Doom4/Other/MeleeSwing1");
			}
			else
			{	//if you have berserk, the quick melee will increase damage, but not as strong as the "fist weapon". This is to encourage to use the fist
				A_CustomPunch(countinv("PowerStrength")? random(50,100) : random(15,35),1,0,"FistPuff",80,0,0,null,"Doom4/Weapon/Melee/Punch","Doom4/Other/MeleeSwing1");
			}
		}
		MELE F 1 A_OverlayOffset(PunchOverlay,0,36);
		MELE F 1 A_OverlayOffset(PunchOverlay,-2,40);
		
		MELE E 1 A_OverlayOffset(PunchOverlay,-3,42);
		MELE E 1 A_OverlayOffset(PunchOverlay,-6,45);
		MELE E 1 A_OverlayOffset(PunchOverlay,-8,48);
		
		MELE D 1 A_OverlayOffset(PunchOverlay,-10,44);
		MELE D 1 A_OverlayOffset(PunchOverlay,-12,47);
		MELE D 1 A_OverlayOffset(PunchOverlay,-15,50) ;
		Stop;
	Overlay.PunchSwayEffect:
		W666 A 1 {  A_SetAngle(angle-1); A_SetRoll(-1.25,SPF_INTERPOLATE); A_SetPitch(pitch-0.5); }
		W666 A 1 {  A_SetAngle(angle-1); A_SetRoll(-2.5,SPF_INTERPOLATE); A_SetPitch(pitch-0.5); }
		W666 A 1 ;
		W666 A 1 ;
		W666 A 1 { A_SetAngle(angle+1); A_SetRoll(-1.5,SPF_INTERPOLATE); A_SetPitch(pitch+0.5); }
		W666 A 1 { A_SetAngle(angle+0.5); A_SetRoll(-0.75,SPF_INTERPOLATE); A_SetPitch(pitch+0.5); }
		W666 A 1 { A_SetAngle(angle+0.5); A_SetRoll(0,SPF_INTERPOLATE); }
		Stop;
	
	
		
	ExecuteExecutions:	//purposefully/purposely silly name
		---- AA 0 A_WeaponOffset(21,60,WOF_ADD);	//lowers weapon
		---- A 1 A_CustomPunch(10000,1,0,"GloryKillPuff",150,0,0,null); //actually kills the Monster; without gibbing it
		---- A 35 A_Overlay(PunchOverlay,"Overlay.Finisher");	//calls the animation
		---- AAA 1 A_WeaponOffset(-7,-40,WOF_ADD);
		---- A 0 
		{ 
			A_SetInventory("BusyToken",0);
			return ResolveState("Ready"); 
		}
	Overlay.Finisher:
		MELE A 0 A_Jump(256,"Finisher1","Finisher2","Finisher3");
		Goto Finisher2;
	Finisher1:
		---- A 0 
		{
			A_GiveInventory("GloryKill1Token",1,TargetPtr);
			A_OverlayFlags(PunchOverlay,PSPF_ADDWEAPON,0);
			A_OverlayOffset(PunchOverlay,0,32);
			SetPlayerProperty(0,1,PROP_TOTALLYFROZEN); //player is made invulnerable, unshootable, unmovable and frozen for the duration of the Glory Kill
			A_UnsetShootable();
			if (!CountInv("PowerInvulBase") && !CountInv("PowerInvulnerable"))
			{	A_SetInvulnerable();	}
			A_Stop();
			bDONTTHRUST = true;
		}
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,50);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,40);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,30);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,-20,40);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,-40,50);
		MELE A 1 A_OverlayOffset(PunchOverlay,40,50);
		MELE B 1 { A_OverlayOffset(PunchOverlay,20,48); A_Playsound("Doom4/Other/MeleeSwing1",CHAN_BODY); }
		MELE C 1 A_OverlayOffset(PunchOverlay,0,40);
		MELE C 1 { A_OverlayOffset(PunchOverlay,-20,35); A_Playsound("Doom4/Weapon/Melee/Punch",CHAN_WEAPON); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-40,35); A_SetAngle(5+angle); A_SetRoll(-5); A_SetPitch(-3); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-60,35); A_SetAngle(5+angle); A_SetRoll(-10); A_SetPitch(-6); }
		MELE C 1 A_OverlayOffset(PunchOverlay,-80,60);
		MELE C 1 A_OverlayOffset(PunchOverlay,-100,80);
		MELE C 1 { A_OverlayOffset(PunchOverlay,-120,100);  A_SetAngle(-2+angle); A_SetRoll(-6); A_SetPitch(-4); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-140,120);  A_SetAngle(-2+angle); A_SetRoll(-3); A_SetPitch(-2); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-180,140);  A_SetAngle(-2+angle); A_SetRoll(0); A_SetPitch(0); }
		MELE C 1 A_OverlayOffset(PunchOverlay,-200,160);
		MELE G 1 A_OverlayOffset(PunchOverlay,20,80);
		MELE G 1 A_OverlayOffset(PunchOverlay,10,70);
		MELE H 1 { A_OverlayOffset(PunchOverlay,0,60); A_Playsound("Doom4/Other/MeleeSwing1",CHAN_BODY); }
		MELE H 1 { A_OverlayOffset(PunchOverlay,10,50);  A_SetRoll(3); A_SetPitch(1); }
		MELE I 1 { A_OverlayOffset(PunchOverlay,10,40);  A_SetRoll(6); A_SetPitch(2); }
		MELE I 1 { A_OverlayOffset(PunchOverlay,10,35); A_Playsound("Doom4/Weapon/Melee/Kick",CHAN_WEAPON); }
		MELE I 1 A_OverlayOffset(PunchOverlay,-10,36);
		MELE I 1 A_OverlayOffset(PunchOverlay,-12,40);
		MELE H 1 A_OverlayOffset(PunchOverlay,-13,48);
		MELE H 1 A_OverlayOffset(PunchOverlay,-16,45);
		MELE H 1 { A_OverlayOffset(PunchOverlay,-18,42);  A_SetRoll(4); A_SetPitch(2); }
		MELE G 1 { A_OverlayOffset(PunchOverlay,-20,50);  A_SetRoll(2); A_SetPitch(1); }
		MELE G 1 { A_OverlayOffset(PunchOverlay,-22,47);  A_SetRoll(0); A_SetPitch(0); }
		MELE G 1 A_OverlayOffset(PunchOverlay,-25,44);
		---- A 0 
		{
			bDONTTHRUST = false;
			A_SetShootable();
			if (!CountInv("PowerInvulBase") && !CountInv("PowerInvulnerable"))
			{	A_UnSetInvulnerable();	}
			A_OverlayOffset(PunchOverlay,1,32); 
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN); 
		}
		Stop;
	Finisher2:	//double punch
		---- A 0 
		{
			A_GiveInventory("GloryKill2Token",1,TargetPtr);
			A_OverlayFlags(PunchOverlay,PSPF_ADDWEAPON,0);
			A_OverlayOffset(PunchOverlay,0,32);
			SetPlayerProperty(0,1,PROP_TOTALLYFROZEN);
			A_UnsetShootable();
			if (!CountInv("PowerInvulBase") && !CountInv("PowerInvulnerable"))
			{	A_SetInvulnerable();	}
			A_Stop();
			bDONTTHRUST = true;
		}
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,50);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,40);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,30);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,-20,40);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,-40,50);
		MELE A 1 A_OverlayOffset(PunchOverlay,40,50);
		MELE B 1 { A_OverlayOffset(PunchOverlay,20,48); A_Playsound("Doom4/Other/MeleeSwing1",CHAN_BODY); }
		MELE C 1 A_OverlayOffset(PunchOverlay,0,40);
		MELE C 1 { A_OverlayOffset(PunchOverlay,-20,35); A_Playsound("Doom4/Weapon/Melee/Punch",CHAN_WEAPON); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-40,35); A_SetAngle(5+angle); A_SetRoll(-5); A_SetPitch(-3); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-60,35); A_SetAngle(5+angle); A_SetRoll(-10); A_SetPitch(-6); }
		MELE C 1 A_OverlayOffset(PunchOverlay,-80,60);
		MELE C 1 A_OverlayOffset(PunchOverlay,-100,80);
		MELE C 1 { A_OverlayOffset(PunchOverlay,-120,100); A_SetAngle(-2+angle); A_SetRoll(-6); A_SetPitch(-4); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-140,120); A_SetAngle(-2+angle); A_SetRoll(-3); A_SetPitch(-2); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-180,140); A_SetAngle(-2+angle); A_SetRoll(0); A_SetPitch(0); }
		MELE C 1 A_OverlayOffset(PunchOverlay,-200,160);
		MELE D 1 A_OverlayOffset(PunchOverlay,-40,50);
		MELE E 1 { A_OverlayOffset(PunchOverlay,-20,48); A_Playsound("Doom4/Other/MeleeSwing1",CHAN_BODY); }
		MELE F 1 A_OverlayOffset(PunchOverlay,0,40);
		MELE F 1 { A_OverlayOffset(PunchOverlay,20,35); A_Playsound("Doom4/Weapon/Melee/Punch",CHAN_WEAPON); }
		MELE F 1 { A_OverlayOffset(PunchOverlay,40,35); A_SetAngle(-5+angle); A_SetRoll(-5); A_SetPitch(-3); }
		MELE F 1 { A_OverlayOffset(PunchOverlay,60,35); A_SetAngle(-5+angle); A_SetRoll(-10); A_SetPitch(-6); }
		MELE F 1 A_OverlayOffset(PunchOverlay,80,60);
		MELE F 1 A_OverlayOffset(PunchOverlay,100,80);
		MELE F 1 { A_OverlayOffset(PunchOverlay,120,100); A_SetAngle(2+angle); A_SetRoll(-6); A_SetPitch(-4); }
		MELE F 1 { A_OverlayOffset(PunchOverlay,140,120); A_SetAngle(2+angle); A_SetRoll(-3); A_SetPitch(-2); }
		MELE F 1 { A_OverlayOffset(PunchOverlay,180,140); A_SetAngle(2+angle); A_SetRoll(0); A_SetPitch(0); }
		MELE F 1 A_OverlayOffset(PunchOverlay,200,160);
		---- A 0 
		{
			bDONTTHRUST = false;
			A_SetShootable();
			if (!CountInv("PowerInvulBase") && !CountInv("PowerInvulnerable"))
			{	A_UnSetInvulnerable();	}
			A_OverlayOffset(PunchOverlay,1,32); 
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
		}
		Stop;
	Finisher3:
		---- A 0 
		{
			A_GiveInventory("GloryKill3Token",1,TargetPtr);
			A_OverlayFlags(PunchOverlay,PSPF_ADDWEAPON,0);
			A_OverlayOffset(PunchOverlay,0,32);
			SetPlayerProperty(0,1,PROP_TOTALLYFROZEN);
			A_UnsetShootable();
			if (!CountInv("PowerInvulBase") && !CountInv("PowerInvulnerable"))
			{	A_SetInvulnerable();	}
			A_Stop();
			bDONTTHRUST = true;
		}
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,50);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,40);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,30);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,-20,40);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,-40,50);
		MELE J 1 { A_OverlayOffset(PunchOverlay,1,40); A_SetAngle(3+angle); A_SetPitch(-2); }
		MELE J 1 { A_OverlayOffset(PunchOverlay,-5,0); A_SetAngle(3+angle); A_SetPitch(-4); A_Playsound("Doom4/Other/MeleeSwing1",CHAN_BODY); }
		MELE J 1 { A_OverlayOffset(PunchOverlay,-10,-40); A_SetAngle(3+angle); A_SetPitch(-8); }
		MELE J 4 { A_OverlayOffset(PunchOverlay,-25,-90); A_Playsound("Doom4/Weapon/Melee/Punch",CHAN_WEAPON); }
		MELE J 1 { A_OverlayOffset(PunchOverlay,-20,-60); A_SetAngle(-2+angle); A_SetPitch(-8); }
		MELE J 1 { A_OverlayOffset(PunchOverlay,-15,-30); A_SetAngle(-2+angle); A_SetPitch(-6); }
		MELE J 1 { A_OverlayOffset(PunchOverlay,-10,0); A_SetAngle(-2+angle); A_SetPitch(-4); }
		MELE J 1 { A_OverlayOffset(PunchOverlay,-5,30); A_SetAngle(-2+angle); A_SetPitch(-2); }
		MELE J 1 { A_OverlayOffset(PunchOverlay,1,60); A_SetAngle(-1+angle); A_SetPitch(0); }
		MELE "]" 1 A_OverlayOffset(PunchOverlay,1,42);
		MELE "]" 1 A_OverlayOffset(PunchOverlay,1,37);
		---- A 0
		{
			bDONTTHRUST = false;
			A_SetShootable();
			if (!CountInv("PowerInvulBase") && !CountInv("PowerInvulnerable"))
			{	A_UnSetInvulnerable();	}
			A_OverlayOffset(PunchOverlay,1,32); 
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
		}
		Stop;
	}
}

Class BusyToken : Inventory { Default { Inventory.InterhubAmount 0; }}

Class FinisherToken : Inventory {}
Class GloryKill1Token : Inventory {}
Class GloryKill2Token : Inventory {}
Class GloryKill3Token : Inventory {}

Class GloryKillPuff : Actor 
{
	Default 
	{
		+NOINTERACTION
		+ALLOWTHRUFLAGS	//to ignore pinky's shield
		+THRUGHOST
		+PUFFGETSOWNER
		+PUFFONACTORS
		+NOTIMEFREEZE
		DamageType "GloryKill";
		+BLOODLESSIMPACT
		+NOEXTREMEDEATH
	}
	States
	{
	Spawn:
		TNT1 A 1 NoDelay A_GiveToTarget("PunchedAlready",1);
		Stop;
	}
}
Class MeleePunchPuff : Actor 
{
	Default 
	{
		DamageType "MeleePunch";
		-BLOODLESSIMPACT
		-NOEXTREMEDEATH
		+ALLOWTHRUFLAGS	//to ignore pinky's shield
		+THRUGHOST
		+PUFFGETSOWNER
		+PUFFONACTORS
		+NOTIMEFREEZE
	}
	
	override void PostBeginPlay()
	{
		Destroy();
	}
}

//=======================================================================
//=======================================================================
// "Give weapons" identifier
//=======================================================================
//=======================================================================
/*
Class D4IdfaTrap : Weapon 
{
	Default 
	{
		Weapon.SlotNumber 0;
	}
	States 
	{ 
		Ready: Deselect: Select: Fire: TNT1 A 1 A_Lower;
	} 
}
*/
Class IdfaStamp : Inventory {}


//=======================================================================
//=======================================================================
// Ledge grabbing hands
//=======================================================================
//=======================================================================

Class ClimbingHands : Weapon
{
	Default 
	{
		+WEAPON.CHEATNOTWEAPON
		+WEAPON.AMMO_OPTIONAL
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
		+INVENTORY.UNDROPPABLE
		+INVENTORY.UNTOSSABLE
		+Weapon.NOAUTOFIRE
	}
	States
	{
	Spawn:
		TNT1 A 0;
		Stop;
	Select:
		M666 A 0 A_Raise;
		Loop;
	Deselect:	
		M666 A 1;	//Needed.
	DesLoop:
		M666 A 0 A_Lower;
		Loop;
	Ready:
		TNT1 A 5 A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
		TNT1 A 1 A_WeaponReady(WRF_NOFIRE);
		Wait;
	Fire:
		M666 A 10;
		Goto Ready;
	}
}


//=======================================================================
//=======================================================================
// Impact Compensation
//=======================================================================
//=======================================================================

Class FallingHands : Weapon
{
	int UVeloz;
	int UVelooz;
	Default 
	{
		+WEAPON.CHEATNOTWEAPON
		+WEAPON.AMMO_OPTIONAL
		+WEAPON.NOAUTOFIRE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
		+INVENTORY.UNDROPPABLE
		+INVENTORY.UNTOSSABLE
	}
	States
	{
	Spawn:
		TNT1 A 0;
		Stop;
	Select:
		TNT1 A 0 A_Raise;
		Loop;
	Deselect:	
		TNT1 A 1;	//Needed.
	DesLoop:
		TNT1 A 0 A_Lower;
		Loop;
	Ready:
		TNT1 A 1 
		{
			if(pos.z != floorz)
			{
				A_SetPitch(pitch + frandom(1,2), SPF_INTERPOLATE);
			}
		}
		TNT1 A 0 A_JumpIf(pos.z == floorz, "Impact");
		Loop;
	Impact:
		TNT1 A 0 
		{
			if(pitch < 80) { A_SetPitch(80, SPF_INTERPOLATE); }
			A_Log("Impact Compensation.");
			A_PlaySound("Doom4/Player/Climb",7); // placeholder sound
			A_Overlay(Overlay_AnglePitch,"Visuals");
		}
		TNT1 A 25;
		TNT1 ABCDEFGH 1 A_SetPitch(pitch * 97 / 100 - frandom(0.1,1.0), SPF_INTERPOLATE);
		TNT1 ABCDEFGHIJKLMNOPQRSTUVWXYZ 1 A_SetPitch(pitch * 95 / 100 - frandom(0.5,1.5), SPF_INTERPOLATE);
		TNT1 ABCDEFGH 1 A_SetPitch(pitch * 90 / 100 - frandom(0.1,1.0), SPF_INTERPOLATE);
		TNT1 A 0 A_TakeInventory("FallingHands",0x7FFFFFFF);
		TNT1 A 0 A_SelectWeapon("D4Pistol");
		TNT1 A 0 A_WeaponReady;
	Visuals:
		PKFS F 25;
		PKFS EDCBA 8; // placeholder hands animation
		Stop;
	Fire:
		TNT1 A 0 A_SelectWeapon("D4Pistol");
		TNT1 A 0 A_WeaponReady;
		Goto Ready;
	}
}

Class FallingSpeed : Inventory { Default { Inventory.MaxAmount 0x7FFFFFFF; } }


//=======================================================================
//=======================================================================
// Doom doll
//=======================================================================
//=======================================================================
Class D4DoomDoll : CustomInventory
{
	Default 
	{
		Scale 0.3;
		Inventory.PickupMessage "Picked up a collectible doomguy!";
	}
	States
	{
	Spawn:
		DOLL A -1;
		Stop;
	PickUp:
		TNT1 A 0
		{
			if (CountInv("D4DoomDollHands") || FindInventory("PowerMorph", true))
			{
				A_GiveInventory("DollUses",3);
			}
			else
			{
				A_GiveInventory("DollUses",4);
				ACS_NamedExecute("D4DoomDoll",0,0,0);
			}
		}
		Stop;
	}
}

Class DollUses : Inventory
{
	Default 
	{
		+INVENTORY.UNTOSSABLE
		+INVENTORY.UNDROPPABLE
		Inventory.InterhubAmount 10;
		Inventory.MaxAmount 10;
		Inventory.Amount 1;
	}
}

Class D4DoomDollPlaying : Inventory
{	Default { Inventory.InterHubAmount 0;	}}

Class D4DoomDollHands : Weapon
{
	Default 
	{
		+WEAPON.CHEATNOTWEAPON
		+WEAPON.AMMO_OPTIONAL
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
		+INVENTORY.UNDROPPABLE
		+INVENTORY.UNTOSSABLE
		+WEAPON.NOAUTOFIRE
	}
	States
	{
	Spawn:
		TNT1 A 0;
		Stop;
	Select:
		M666 A 0 
		{
			A_OverlayFlags(PSP_WEAPON, PSPF_POWDOUBLE, false);
			A_Raise(20000);
		}
		Loop;
	Deselect:	
		M666 A 1;	//Needed.
	DesLoop:
		M666 A 0 A_Lower;
		Loop;
	Ready:
		TNT1 A 0 
		{
			A_GiveInventory("DollBuddha");
			if (CountInv("D4DoomDollUpgrade1"))
			{
				A_GiveInventory("DollSpeed");
				A_GiveInventory("DollJump");
			}
			A_Overlay(200, "Overlay.BroFist");
			
		}
		TNT1 A 1;
		Wait;
	Overlay.BroFist:
		TNT1 AAAA 1 
		{
			int OID = OverlayID();
			A_OverlayFlags(OID, PSPF_POWDOUBLE, false);
			A_OverlayOffset(OID,-8,20,WOF_ADD);
		}
		DDLL AAAAAAAA 1 A_OverlayOffset(OverlayID(),4,-10,WOF_ADD);
		DDLL A 70;
		DDLL BCDEE 1 ;
		DDLL F 1
		{
			if (CountInv("D4DoomDollUpgrade2"))
			{
				A_SpawnItemEx("DollExplosion",flags: SXF_NOCHECKPOSITION);
				bFORCERADIUSDMG = bFOILINVUL = true;
				A_Explode(2048, 1024, XF_NOTMISSILE, false, 512);
				bFORCERADIUSDMG = bFOILINVUL = false;
			}
			A_GiveInventory("DollProtection");
			A_GiveInventory("DollPush");
			A_GiveInventory("D4MegaSphereNoBonus");
			if (CountInv("D4RegenUpgrade4") && health < 300)
			{	A_SetHealth(300);	}
			A_TakeInventory("DollUses",1,0);
			A_SpawnItemEx("BroFistPuff",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION);
		}
		DDLL FFFF 1;
		DDLL GHIJKLMNOPQRSTUVWXYZ 2;
		DDL2 ABCDEFGHI 2;
		DDLL AAAAAAAA 1 A_OverlayOffset(OverlayID(),-14,20,WOF_ADD);
		TNT1 A 5 ;
		TNT1 A 10000; //just to ensure it wont play again while the script takes it away
		Wait;
	Fire:
		M666 A 1;
		Goto Ready;
	}
}

Class BroFistPuff : Actor 
{
	Default 
	{
		+NOINTERACTION
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay
		{
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);

		}
		TNT1 A 10;
		Stop;
	}
}

Class DollExplosion : Actor
{
	Default
	{
		+NOINTERACTION
		+NOBLOCKMAP
		+NOSECTOR
	}
	States
	{
	Spawn:
		TNT1 A 200 NoDelay A_PlaySound("Doom4/Other/DollExplode",CHAN_WEAPON,1,0,ATTN_NONE);
		Stop;
	}
}

Class DollProtBase : PowerProtection
{
	Default 
	{
		DamageFactor "Normal", 0.05;	//takes a tiny bit of damage
	}
}

Class DollProtection : PowerupGiver
{
	Default 
	{
		powerup.duration -8;
		+INVENTORY.QUIET
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.UNDROPPABLE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
		Powerup.Type "DollProtBase";
	}
	States
	{
	Spawn:
		MEGA A 4 Bright;
		Loop;
	}
}

Class DollPush : ArtiBlastRadius
{
	Default 
	{
		+INVENTORY.QUIET
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.UNDROPPABLE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
	}
	States
	{
	Spawn:
		MEGA A 4 Bright;
		Loop;
	}
}

Class DollBuddha : PowerupGiver
{
	Default 
	{
		+INVENTORY.QUIET
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
		+INVENTORY.UNDROPPABLE
		Powerup.Type "PowerBuddha";
		Powerup.Duration 170;
	}
}

Class DollSpeed : PowerupGiver
{
	Default 
	{
		+INVENTORY.QUIET
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
		+INVENTORY.UNDROPPABLE
		Powerup.Type "PowerSpeed";
		Powerup.Duration 170;
	}
}

Class DollJump : PowerupGiver
{
	Default 
	{
		+INVENTORY.QUIET
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
		+INVENTORY.UNDROPPABLE
		Powerup.Type "PowerHighJump";
		Powerup.Duration 170;
	}
}


//=======================================================================
//=======================================================================
// Casings
//=======================================================================
//=======================================================================

Class D4BulletCasing : Actor 
{
	double RollAmt;
	Default 
	{
		Projectile;
		-NOGRAVITY
		+THRUACTORS
		+NOTRIGGER
		+FORCEXYBILLBOARD
		+ROLLSPRITE
		Radius 4;
		Height 2;
		Gravity 0.7;
		Scale 0.15;
		Bouncetype "Doom";
		BounceFactor 0.5;
		BounceSound "Doom4/Weapon/BulletCasing";
	}
	override void PostBeginPlay()
	{
		bSPRITEFLIP = random(0,1);
		Roll = random(0,359);
		RollAmt = frandom(5.0, 25.0) * frandompick(-1.0, 1.0);
		Super.PostBeginPlay();
	}
	States
	{
	Spawn:
		CSNG C 1 A_SetRoll(Roll + RollAmt, SPF_INTERPOLATE); //A_SpawnParticle("696969",0,random(20,40),random(1,2),0,0,0,0,0,0,frandom(0.1,0.6))
		Loop;
	Death:
		---- A 100
		{
			bNOINTERACTION = bMOVEWITHSECTOR = true;
			bROLLSPRITE = false;
			A_Stop();
			if (D4D_ShortCasingLives) Destroy();
		}
		Stop;
	}
}

Class D4BulletCasingSilent : D4BulletCasing
{	Default { BounceSound ""; }}

Class D4ShellCasing : D4BulletCasing 
{
	States
	{
	Spawn:
		SHLL C 1 A_SetRoll(Roll + RollAmt, SPF_INTERPOLATE); //A_SpawnParticle("696969",0,random(20,40),random(1,2),0,0,0,0,0,0,frandom(0.1,0.6))
		Loop;
	}
}

Class D4ShellCasingSilent : D4ShellCasing
{	Default { BounceSound ""; }}



//=======================================================================
//=======================================================================
// Tracers
//=======================================================================
//=======================================================================



Class NonPuff : Actor
{
	Default
	{
		+NOINTERACTION
		+NOBLOCKMAP
		+PAINLESS
		+BLOODLESSIMPACT
		+NOTIMEFREEZE
		+PUFFONACTORS
		+SKYEXPLODE
		+HITTRACER
		Radius 1;
		Height 1;
		Renderstyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 3;
		Stop;
	}
}

Class NonPuff2 : NonPuff
{
	States
	{
	Spawn:
		TNT1 A 15;
		Stop;
	}
}

Class NonPuffThru : NonPuff
{
	Default
	{
		+ALLOWTHRUFLAGS
		+THRUACTORS
	}
}

Class PistolTracerNormal : FastProjectile
{
	Default 
	{
		Projectile;
		+RANDOMIZE
		+FORCEXYBILLBOARD
		+DONTSPLASH
		+NOEXTREMEDEATH
		+NOTIMEFREEZE
		damage 0;
		radius 2;
		height 2;
		speed 200;
		RenderStyle "Add";
		alpha 0.9;
		scale 0.2;
		Translation "0:255=%[0,0,0]:[0.5,0.65,1.5]";
	}
	states
	{
	Spawn:
		TRAC A 10 BRIGHT;
		Stop;
	Death:
		TNT1 A 1;
		Stop;
	XDeath:
		TNT1 A 1;
		Stop;
	}
}

Class PistolTracerRed : FastProjectile
{
	Default 
	{
		Projectile;
		+RANDOMIZE
		+FORCEXYBILLBOARD
		+DONTSPLASH
		+NOEXTREMEDEATH
		+NOTIMEFREEZE
		damage 0;
		radius 2;
		height 2;
		speed 200;
		RenderStyle "Add";
		alpha 0.9;
		scale 0.2;
		Translation "0:255=%[0,0,0]:[1.5,0,0]";
	}
	states
	{
	Spawn:
		TRAC A 10 BRIGHT;
		Stop;
	Death:
		TNT1 A 1;
		Stop;
	XDeath:
		TNT1 A 1;
		Stop;
	}
}

Class BulletSmallTracer : Actor
{
	Actor Puff;
	bool DestroyMe, HadPuff, FirstTic;
	double Dist;
	double _cos, _sin;
	const RealSpeed = 200.0;
	Default 
	{
		Projectile;
		+RANDOMIZE
		+FORCEXYBILLBOARD
		+DONTSPLASH
		+NOEXTREMEDEATH
		+NOTIMEFREEZE
		+PAINLESS
		+BLOODLESSIMPACT
		+NODAMAGETHRUST
		+NOINTERACTION
		Damage 0;
		Radius 2;
		Height 2;
		Speed 0;
		RenderStyle "Add";
		Alpha 0.9;
		Scale 0.13;
		//Translation "0:255=%[0,0,0]:[0,1,1.5]";
	}
	override void OnDestroy()
	{
		if (Puff)	
		{
			if (Puff.bINVISIBLE)
				Puff.Destroy();
		}
		Super.OnDestroy();
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if (Tracer)
		{
			HadPuff = true;
			Dist = Distance3DSquared(Tracer);
		}
		else	Dist = -1.0;
		
		_cos = cos(pitch) * RealSpeed;
		_sin = -sin(pitch) * RealSpeed;
	}
	
	override void Tick()
	{	
		Super.Tick();
		if (bKILLED || IsFrozen())	
			return;
		
		Puff = (Tracer) ? Tracer : LineAttack(angle, RealSpeed + 1, pitch, -1, '', "NonPuffThru", LAF_NOINTERACT);
		if (Puff)
		{
			double CurDist = Distance3DSquared(Puff);
			if (CurDist <= (RealSpeed ** 2))
			{
				bKILLED = true;
				double CurRoot = sqrt(CurDist);
				Warp(Self, cos(pitch) * CurRoot, 0, -sin(pitch) * CurRoot, 0, WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE);
				ExplodeMissile(null, null);
				return;
			}
		}
		Warp(Self, _cos, 0, _sin, 0, WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE);
	}
	
	States
	{
	Spawn:
		TRAC A 10 Bright;
		Stop;
	Death:
		TRAC A 1 Bright;
		Stop;
	}
}


Class D4AbstractMissile : D4Actor 
{
	bool HQ;
	
	override void PostBeginPlay()
	{
		HQ = GetCvar("HQEffects");
		if (Target)
		{
			if (Target.bISMONSTER && Target.Species == 'DemonPlayerBase')
			{
				Species = Target.Species;
				bTHRUSPECIES = bMTHRUSPECIES = true;			
			}
			Tracer = Target.Target;
			
			if (Tracer && Tracer.Vel != (0,0,0) && !Tracer.FindInventory("PowerInvisibility",true) && 
				GetCvar("D4D_MonProjIntercept"))
			{
				D4D_Intercept.InterceptActor(self, Tracer, IAF_AIM|IAF_CLIPZ);
			}
		}
		Super.PostBeginPlay();
	}
	
	void StartRocketFX()
	{
		A_SpawnItemEx("D4RocketTrailFire", flags: SXF_NOCHECKPOSITION|SXF_SETTARGET|SXF_ORIGINATOR);
	}
	
	// Spawns smoke.
	virtual void SpawnRocketFX()
	{
		A_SpawnItemEx("D4RocketTrailSmoke",-5,random(5,-5),random(5,-5),0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETTARGET|SXF_ORIGINATOR);
	}
}

Class D4AbstractMissilePlayer : D4AbstractMissile
{
	override void PostBeginPlay()
	{
		// Don't call the super function. This is obviously a player missile
		// so no need for the species assignment and stuff.
		Actor.PostBeginPlay();
		HQ = GetCvar("HQEffectsWeapons");
	}
}

Class D4AbstractMissileQuake : D4AbstractMissile
{
	transient CVar QuakeC;
	bool DoQuake;
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		QuakeC = CVar.FindCvar("D4D_quakexplosions");
		if (QuakeC)	DoQuake = QuakeC.GetBool();
	}
}


//------------------------------------------------------------------------------
//	
// The following code is courtesy of phantombeta, which can be found here:
// https://github.com/Doom2fan/Se7evidas/blob/master/PK3%20Source/S7ZScript/Bases/Base%20Actors.ZS
//
// Further modifications by Major Cooke
// 
// Projectile bases
// 
//------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------
//
// Misc bases
//
//-------------------------------------------------------------------------------------------
/** Monster spawner base
*** Usage: Works exactly like RandomSpawner, except you can override MS_GetMonsterSpawnList to change the spawner's behaviour.
*** Virtuals:
***     void PostSpawn (Actor spawned): Called when the actor is finished spawning. (From RandomSpawner)
***     DropItem MS_GetMonsterSpawnList (): called when getting the monster spawn list. (From D4D_MonsterSpawner)
**/


/** Trace test puffs **/
class D4D_TraceTestPuff : Actor 
{
    default 
	{
        Radius 1;
        Height 1;
        +NOBLOCKMAP +ALLOWTHRUFLAGS +NOINTERACTION +NOTIMEFREEZE
        +BLOODLESSIMPACT +PAINLESS
    }

    States 
	{
    Spawn:
    Death:
        TNT1 A 1;
        stop;
    }
}

class D4D_WallCheckPuff : D4D_TraceTestPuff 
{	default {	+THRUACTORS	}	}

//-------------------------------------------------------------------------------------------
//
// Projectile base
//
//-------------------------------------------------------------------------------------------
class D4D_Projectile_Trace : LineTracer 
{
	D4D_Projectile sourceActor;
	Array<Actor> actorsToIgnore;

	override ETraceStatus TraceCallback() 
	{
		/*if (!sourceActor)
			return TRACE_Skip;*/

		switch (Results.HitType) 
		{
			case TRACE_HitActor:
				if (sourceActor.bThruActors)
					return TRACE_Skip;

				let mo = Results.HitActor;
				
				if (actorsToIgnore.Size() > 0)
				{
					for (int i = 0; i < actorsToIgnore.Size(); i++) 
					{
						if (mo == actorsToIgnore [i])
							return TRACE_Skip;
					}
				}
				if (mo != sourceActor && (sourceActor.bMissile && mo != sourceActor.target)) 
				{
					if (!(mo.bSolid || mo.bSpecial || mo.bShootable || mo.bTouchy))
						return TRACE_Skip;
					if (mo.bThruActors)// || (sourceActor.bThruSpecies && mo.GetSpecies () == sourceActor.GetSpecies ()))
						return TRACE_Skip;

					return TRACE_Stop; // && sourceActor.CanCollideWith (Results.HitActor)
				} 
				else
					return TRACE_Skip;
			break;

			case TRACE_HitFloor:
			case TRACE_HitCeiling:
				return TRACE_Stop;
			break;

			case TRACE_HitWall:
				if (Results.Tier == TIER_Upper || Results.Tier == TIER_Lower) return TRACE_Stop;

				let hl = Results.HitLine;
				if (sourceActor.bMissile && (hl.flags & (Line.ML_BLOCKPROJECTILE | Line.ML_BLOCKEVERYTHING)))
					return TRACE_Stop;
				
				if (sourceActor.bMissile && Results.Tier == TIER_Middle && (hl.flags & Line.ML_BLOCKING) && (hl.flags & Line.ML_TWOSIDED))
					return TRACE_Skip;
				
				if ((hl.flags & Line.ML_BLOCKING) || (hl.flags & Line.ML_BLOCKEVERYTHING) || (sourceActor.bIsMonster && (hl.flags & Line.ML_BLOCKMONSTERS)))
					return TRACE_Stop;
			break;
		}
		return TRACE_Skip;
	}
}

// The base type for all fast projectiles

class D4D_Projectile_New : S7_Projectile
{
	Default
	{
		S7_Projectile.MovementMode FastProjectile;
		+DONTREFLECT
	}
}

class D4D_Projectile : FastProjectile 
{
    enum EMovementMode 
	{
        Normal = 0, /// The projectile uses the normal movement code.
        FastProjectile, /// The projectile is a FastProjectile.
        OldFastProj, /// The projectile is a FastProjectile and uses GZDoom's code.
    };
    /// Determines how to detect collisions. Only used for EMovementMode.FastProjectile.
    enum EFPCollisionMode 
	{
        ColMode_Center      = 1, /// Check the center for collision
        ColMode_Corners     = 1 << 1, /// Check the corners for collision
        ColMode_EdgeCenters = 1 << 2, /// Check the center of the edges for collision.
    };
	private bool exploded;
    int moveMode;
    int fpCollisionMode;
    bool interpFastProj;
    double effectStepMul;

    /// Which movement code to use.
    property MovementMode: moveMode;
    /// How to detect collisions. Only used by EMovementMode.FastProjectile.
    property FastProjCollision: fpCollisionMode;
    /// Changes how many times StepEffects is called. Only used by EMovementMode.FastProjectile.
    property EffectStepMul: effectStepMul;
    /// Whether to interpolate the projectile's movement. Only used by EMovementMode.FastProjectile.
    property InterpMove: interpFastProj;

    Default 
	{
		//D4D_Projectile.MovementMode FastProjectile;
		D4D_Projectile.FastProjCollision ColMode_Center;
		D4D_Projectile.InterpMove true;
		D4D_Projectile.EffectStepMul 0.125;
        Projectile;
    }

    transient D4D_Projectile_Trace tr;
	/*
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if (Target && !Tracer)	Tracer = Target.Target;
		if (Tracer && Tracer.Vel != (0,0,0) && GetCvar("D4D_MonProjIntercept"))
		{
			VelIntercept(Tracer);
		}
		
	}
	*/
	override void Tick() 
	{
		if (exploded)	
		{	Actor.Tick();	return;	}
		
		if (!self)
            return;

        ClearInterpolation();
        let oldPos = pos;
        let oldVel = vel;

        if (!bNoTimeFreeze && IsFrozen())
            return;

        if (vel != (0, 0, 0) || (pos.Z != floorz)) 
		{	// Create a tracer
            if (!tr) 
			{
				tr = new ("D4D_Projectile_Trace"); 
				tr.sourceActor = self; 
			}
            tr.actorsToIgnore.Clear();

            if (bMissile && vel.X == 0 && vel.Y == 0 && !IsZeroDamage())
                vel.X = MinVel;

            let velUnit = vel.Unit();
            double velAngle = VectorAngle(velUnit.x, velUnit.y);
            double s = sin (velAngle);
            double c = cos (velAngle);

            double maxDist = abs(vel.Length());
            int colFlags = (fpCollisionMode & (ColMode_Center | ColMode_Corners | ColMode_EdgeCenters));
            int iMax = FPColOffs.Size () / 2;

            int loopBreaker = 0;
            bool collisionHandled = false;
            for (int i = 0; i < iMax; i++) 
			{
					 if ((i >= 0 && i <= 3) && 	!(colFlags & ColMode_EdgeCenters))
                    continue;
                else if ((i >= 4 && i <= 7) && 	!(colFlags & ColMode_Corners))
                    continue;
                else if ((i == 8) && 			!(colFlags & ColMode_Center))
                    continue;

                tr.actorsToIgnore.Clear();

                do 
				{
                    double yOffs = radius * FPColOffs [i * 2];

                    if (tr.Trace(Vec3Offset(s * yOffs, c * yOffs, height * FPColOffs [i * 2 + 1]), curSector, velUnit, maxDist, 0)) 
					{
                        if (!self)
                            return;

						if (HandleCollision(oldPos, oldVel)) 
						{
							if (!self)
								return;

							tr.actorsToIgnore.Clear();
							collisionHandled = true;
							break;
						}
                    } 
					else
                        tr.actorsToIgnore.Clear();

                    loopBreaker++;
                    if (loopBreaker >= 10000) 
					{ // Uh oh.
                        //Console.PrintF ("Broke an infinite loop.");
						exploded = true;
                        Destroy();
                        return;
                    }
                } 
				while (tr.actorsToIgnore.Size() > 0);

                if (collisionHandled)
                    break;
            }

            if (!collisionHandled)
                SetOrigin(pos + vel, true);
            TryMove(pos.xy, true, false);
			
			class<Actor> trail = MissileName;
			if (trail && !exploded)
				SpawnEffects(oldPos, level.Vec3Diff (pos, oldPos).Length (), oldVel);

            if (!collisionHandled) 
			{
                bool floorHit = pos.Z <= floorZ;
                bool ceilingHit = (pos.Z + height) > ceilingZ;

                bool hitSky = ((  floorHit &&   floorpic == skyflatnum) ||
                               (ceilingHit && ceilingpic == skyflatnum));
				
                if (hitSky && !bSkyExplode) 
				{
					exploded = true;
					A_Stop();
                    Destroy();
                    return;
                } 
				else if (floorHit || ceilingHit) 
				{
                    SetZ(floorHit ? GetZAt() : ceilingZ - height);

                    if (floorHit)
                        HitFloor();

                    A_Stop();
                    if (bMissile)
					{
						exploded = true;
                        ExplodeMissile (NULL, NULL, hitsky);
					}
                }
            }

            vel.z += GetGravity ();

            UpdateWaterLevel ();
            CheckPortalTransition ();
        }

        // Nope the fuck out if self is null for some retarded reason, or freed itself
        if (!self || !CheckNoDelay())
            return;
			
        // Advance the state
        if (tics != -1) 
		{
            if (tics > 0)
                tics--;

            while (!tics) 
			{
                if (!self || !CurState || !SetState(CurState.NextState)) // mobj was removed
                    return;
            }
        }
	}

    virtual Actor StepEffects (Vector3 initialPos, Vector3 stepDiff, Vector3 realVel) 
	{
        class<Actor> trail = MissileName;

        if (trail) 
		{
            Vector3 finalPos = initialPos + stepDiff;

            Actor act = Spawn (trail, initialPos, ALLOW_REPLACE);
            act.SetOrigin (finalPos, false);

            double realFloorZ = GetZAt (finalPos.X, finalPos.Y, flags: GZF_AbsolutePos | GZF_AbsoluteAng);

            double hitz = finalPos.z - 8;
            if (hitz < realFloorZ)
                hitz = realFloorZ;
            // Do not clip this offset to the floor.
            hitz += missileHeight;

            act.SetOrigin ((finalPos.xy, hitz), false);

            if (act) 
			{
                if (bGetOwner && target)
                    act.target = target;
                else
                    act.target = self;
                
                act.angle = angle;
                act.pitch = pitch;
            }
            return act;
        }
        return null;
    }

    void SpawnEffects (Vector3 initialPos, double dist, Vector3 stepSize) 
	{
        if (radius <= 0 || dist <= 0 || exploded)
            return;

        int count = 8;
        while (abs (stepSize.X) > radius * count || abs (stepSize.Y) > radius * count)
            count += count;

        Vector3 frac = stepSize / count;

        int spawnCount = int (count * effectStepMul);
        for (int i = 0; i < count; i++) 
		{
            double diff = abs ((frac * i).Length ());

            if (diff >= dist)
                break;

            if (--spawnCount <= 0) 
			{
                spawnCount = int (count * effectStepMul);
                StepEffects (initialPos, frac * i, stepSize);
            }
        }
    }

	//--------------------------------------------------------------------------
	// Offsets based on Y and Z instead of X and Y
    static const double FPColOffs[] = 
	{ 
        // Edge centers
         0, 1.0,
         1, 0.5,
         0, 0.0,
        -1, 0.5,
        // Corners
         1, 1,
         1, 0,
        -1, 0,
        -1, 1,
        // Center
        0, 0.5
    };
	
    virtual void NewFastProjTick() 
	{
        
    }

    bool HandleCollision(Vector3 oldPos, Vector3 oldVel) 
	{
        if (abs(level.Vec3Diff(oldPos, tr.Results.hitPos).Length()) > abs (oldVel.Length()) + radius) 
		{
            if (tr.Results.HitType == TRACE_HitActor && tr.Results.HitActor)
                tr.actorsToIgnore.Push(tr.Results.HitActor);

            return false;
        }

        double maxDist = abs(oldVel.Length());
        double hitPosDist = abs(tr.Results.hitPos.Length());
        let hitPos = tr.Results.HitPos;
        hitPos += -(oldVel.Unit() * abs (radius));

        SetOrigin (hitPos, interpFastProj);

        if (!bSKYEXPLODE) 
		{
            if (tr.Results.HitType == TRACE_HitWall && tr.Results.HitLine) 
			{
                let l = tr.Results.HitLine;
                if (l.backsector && l.backsector.GetTexture (sector.ceiling) == skyflatnum) 
				{
                    let posr = PosRelative (l.backsector);
                    if (pos.Z >= l.backsector.ceilingplane.ZatPoint (posr.XY)) 
					{
                        // Hack to prevent missiles exploding against the sky.
                        // Does not handle sky floors.
                        SpawnEffects (oldPos, tr.Results.Distance, oldVel);
                        Destroy();
                        return true;
                    }
                }

                // [RH] Don't explode on horizon lines.
                if (l && l.special == Line_Horizon) 
				{
                    SpawnEffects (oldPos, tr.Results.Distance, oldVel);
                    Destroy();
                    return true;
                }
            } 
			else if ((tr.Results.HitType == TRACE_HitFloor && floorpic == skyflatnum) ||
                (tr.Results.HitType == TRACE_HitCeiling && ceilingpic == skyflatnum)) 
			{
                SpawnEffects (oldPos, tr.Results.Distance, oldVel);
                Destroy();
                return true;
            }
        }

        if (tr.Results.HitType == TRACE_HitFloor)
            hitPos = tr.Results.HitPos;
        else if (tr.Results.HitType == TRACE_HitCeiling) {
            hitPos = tr.Results.HitPos;
            hitPos -= (0, 0, height);
        }

        Vector3 rHitPos = tr.Results.HitPos;

        double realFloorZ = GetZAt(rHitPos.X, rHitPos.Y, flags: GZF_AbsolutePos | GZF_AbsoluteAng);
        double realCeilingZ = GetZAt(rHitPos.X, rHitPos.Y, flags: GZF_AbsolutePos | GZF_AbsoluteAng | GZF_Ceiling);

        bool floorHit = (rHitPos.Z <= realFloorZ || rHitPos.Z ~== realFloorZ);
        bool ceilingHit = (rHitPos.Z + height) > realCeilingZ;

        FCheckPosition tm;
        tm.DoRipping = bRipper;

        if (!TryMove(hitPos.XY + (double.epsilon * 3, double.epsilon * 3), true, tm: tm)) 
		{
            SetOrigin(hitPos, interpFastProj);

            bool hitSky = ((  floorHit &&   floorpic == skyflatnum) ||
                           (ceilingHit && ceilingpic == skyflatnum));

            A_Stop();
            ExplodeMissile(BlockingLine, BlockingMobj, (!BlockingLine && !BlockingMobj) ? hitSky : false);
			exploded = true;
            return true;
        } 
		else if (tr.Results.HitType == TRACE_HitActor && tr.Results.HitActor)
            tr.actorsToIgnore.Push (tr.Results.HitActor);
        else 
		{
            if ((tr.Results.HitType == TRACE_HitFloor && floorHit) ||
                (tr.Results.HitType == TRACE_HitCeiling && ceilingHit)) 
			{
                SetOrigin(hitPos, interpFastProj);

                bool hitSky = ((  floorHit &&   floorpic == skyflatnum) ||
                               (ceilingHit && ceilingpic == skyflatnum));

                if (tr.Results.HitType == TRACE_HitFloor) 
				{
                    SetZ(floorZ);
                    HitFloor();
					exploded = true;
                }

                if (bMissile) 
				{
					exploded = true;
                    A_Stop();
                    ExplodeMissile(NULL, NULL, hitSky);
                }

                return true;
            }
		//	else if (D4D_DebugMode >= 1)
		//		Console.PrintF ("zzz %f ----- %f, %d", rHitPos.Z, GetZAt (rHitPos.X, rHitPos.Y, flags: GZF_AbsolutePos | GZF_AbsoluteAng), floorHit);
        }

        SetOrigin(oldPos, false);
        return false;
    }
}