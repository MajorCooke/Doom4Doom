#include "ZD4D/Weapons/GrenadeLauncher.txt"

const SparsitySmall = 100.0; //10.415;
//==============================================================================
//==============================================================================
//
//		Base weapon for all D4D 
//
//==============================================================================
//==============================================================================
Class Doom4Weapon : Weapon
{
	const GrenadeOverlay = 50;
	const GrenadePrimer = 51;
	const PunchOverlay = 52;
	const PunchSway = 53;
	
	Inventory Modules[2];
	Inventory ActiveMod;
	Array<D4DNewBeamBase> Beams;
	
	// Gets the player preference for performing secondary priming or not.
	// Defaults to performing the secondary priming if the owner's not a player
	// or the cvar isn't found.
	action bool DoSecondaryPriming()
	{
		let plr = invoker.owner.player;
		
		// Voodoo doll check.
		if (!plr || !plr.mo || plr.mo != invoker.owner)
			return true;
			
		CVar check = CVar.GetCVar("D4D_SecondaryPriming", plr);
		return (!check || check.GetBool());
	}
	
	// Default offsets are 10.0, 4.1, -2.7
	action void A_StartBeam(
		Class<D4DNewBeamBase> BeamName, Vector3 Off = (0,0,0), int Count = 1,
		Class<Actor> PuffName = "D4BulletPuff", int dmg = 0, double ang = 0, double pit = 0,
		double dist = 8192)
	{
		Count = Max(1, Count);
		
		Vector3 x, y, z, origin;
		[x, y, z] = Matrix4.GetAxes(Pitch,Angle,Roll);
		origin = Vec2OffsetZ(0,0,player.viewz) + Off.x * x + Off.y * y + Off.z * z;
		
		if (dist <= 0.0)	dist = 8192.0;
		Actor Puff = LineAttack(angle + ang, dist, pitch + pit, dmg, 'None', PuffName, LAF_NOINTERACT);
		for (int i = 0; i < Count; i++)
		{
			let Beam = D4DNewBeamBase(Spawn(beamname,origin));
			Beam.Angle = Angle;
			Beam.Pitch = Pitch;
			Beam.Target = invoker.owner;
			Beam.Master = invoker.owner;
			Beam.Tracer = Puff;
			Beam.OffX = Off.x;
			Beam.OffY = Off.y;
			Beam.OffZ = Off.z;
			Beam.Parent = null;
			invoker.Beams.Push(Beam);
		}
	}
	
	action void A_UpdateBeamTracer(
		Class<Actor> PuffName = "D4BulletPuff", int dmg = 0, double ang = 0, double pit = 0,
		double dist = 8192)
	{
		int flags = LAF_NORANDOMPUFFZ;
		if (dmg <= 0)	flags |= LAF_NOINTERACT;
		Actor Puff = LineAttack(angle + ang, dist, BulletSlope() + pit, dmg, '', PuffName, flags);
		
		if (invoker.Beams.Size() < 1)	return;
		for (int i = 0; i < invoker.Beams.Size(); i++)
		{
			let mo = invoker.Beams[i];
			if (!mo)	continue;
			
			if (Puff)	mo.Tracer = Puff;
		}
	}
	
	action void A_StopBeam(Sound StopSound = "")
	{
		A_StopSound(CHAN_WEAPON);
		A_PlaySound(StopSound, CHAN_WEAPON);
		if (invoker.beams.Size() > 0)
		{
			for (int i = 0; i < invoker.beams.Size(); i++)
			{
				let mo = invoker.Beams[i];
				if (mo)	mo.Die(null, null);
			}
			invoker.Beams.Clear();
		}
	}
	
	override bool CheckAmmo(int firemode, bool autoswitch, bool requireAmmo, int ammocount)
	{
		if (ammocount == 0)
			return true;
		else if (ammocount < 0)
		{
			return Super.CheckAmmo(firemode, autoswitch, requireammo);
		}
		int temp = AmmoUse1;
		AmmoUse1 = ammocount;
		bool check = Super.CheckAmmo(firemode, autoswitch, requireammo);
		AmmoUse1 = temp;
		return check;
	}
	
	action int DoubleSpeed()
	{	return (invoker.owner.FindInventory("PowerDoubleFiringSpeed", true) != null) ? 2 : 1;	}
	
	action bool IsDoubleSpeed()
	{	return (invoker.owner.FindInventory("PowerDoubleFiringSpeed", true) != null);	}
	
	action Actor FireProjectile(Class<Actor> proj, Vector3 off, bool useammo = true)
	{
		let o = invoker.owner;
		Vector3 px, py, pz, origin;
		[px, py, pz] = Matrix4.GetAxes(Pitch,Angle,Roll);
		origin = Vec2OffsetZ(0,0,player.viewz) + off.x * px + off.y * py + off.z * pz;
		if (useammo)	A_FireProjectile("Nothing",0,true);
		let gren = Spawn(proj, origin, ALLOW_REPLACE);
		if (gren)
		{
			gren.target = self;
			gren.angle = angle;
			gren.Vel3DFromAngle(gren.speed, angle, pitch);
		}
		return gren;
	}
	
	override void OwnerDied()
	{
		A_StopBeam();
		Super.OwnerDied();
	}
	override void DetachFromOwner()
	{
		A_StopBeam();
		Super.DetachFromOwner();
	}
	override void OnDestroy()
	{
		A_StopBeam();
		Super.OnDestroy();
	}
	
	Default 
	{
		+INVENTORY.UNDROPPABLE
		+INVENTORY.UNTOSSABLE
		+DONTGIB
		Weapon.BobStyle "Alpha";
		Weapon.BobSpeed 2.0;
		Weapon.BobRangeX 0.7;
		Weapon.BobRangeY 0.5;
		Weapon.UpSound "Doom4/Weapons/WeaponSwitch";
		Inventory.PickupSound "Doom4/Other/WeaponPickup";
		Inventory.RespawnTics 175;
		Tag "REPLACE ME YOU IDIOT!";
	}
	
	States
	{
	Spawn:
		TNT1 A 1;
		Stop;
	Pickup:
		TNT1 A 0 ACS_NamedExecuteAlways("UpdateWeaponList",0,0,0,0);
		Stop;
	Reload:	//since there's no reload, we used this key to throw grenades
		"####" "#" 1
		{
			
			return ResolveState(null);
			
			if(countinv("FragGrenadeSelected")|| countinv("SyphonGrenadeSelected")|| countinv("MarineHoloSelected"))
			{
				return ResolveState("ThrowGrenade");
			}
			else
			{
				if (GetPlayerInput(MODINPUT_OLDBUTTONS) & BT_RELOAD)
				{	return ResolveState(null);	}
			
				ACS_NamedExecute("GrenadeUnavailPrint",0,4); //print "No grenade available"
				A_PlaySound("Doom4/Player/Nope",CHAN_AUTO);
			}
			return ResolveState(null);
		}
		"####" "#" 0 { return ResolveState("Ready"); }	//goes back to ready
	ThrowGrenade:
		"####" "#" 1
		{
			// Prevent message spam.
			if (GetPlayerInput(MODINPUT_OLDBUTTONS) & BT_RELOAD)
			{	return ResolveState(null);	}
			if (CountInv("GrenadeCooldown"))
			{	
				ACS_NamedExecute("GrenadeUnavailPrint",0,5); //print "grenade not ready"
				A_PlaySound("Doom4/Player/Nope",CHAN_AUTO);
				return ResolveState(null);
			}
			A_GiveInventory("BusyToken");
			return ResolveState("GrenadeReady");
		}
		"####" "#" 0 { return ResolveState("Ready"); }
		
	GrenadeReady:
		"####" "###" 1 A_WeaponOffset(11,16,WOF_ADD);	//lowers weapon
		"####" "#" 2;
		"####" "#" 15 A_Overlay(GrenadeOverlay,"Overlay.GrenadeToss");	//calls the throwing hand 
		"####" "###" 1 A_WeaponOffset(-11,-16,WOF_ADD);
		"####" "#" 0 { A_TakeInventory("BusyToken",32767); return ResolveState("Ready"); }
		
	Overlay.GrenadeToss:
		D4GR A 0 
		{
			if (CountInv("FragGrenadeSelected")>=1)
			{
				A_PlaySound("Doom4/Weapon/Grenade/ThrowGren",5);
				A_FireProjectile("D4FragGrenade",0,0,-8,6);
			}
			
			else if (CountInv("SyphonGrenadeSelected")>=1)
			{
				A_PlaySound("Doom4/Weapon/Grenade/ThrowGren",5);
				A_FireProjectile("D4SyphonGrenade",0,0,-8,6);
			}
			
			else if (CountInv("MarineHoloSelected")>=1)
			{
				A_PlaySound("Doom4/Weapon/Grenade/SpawnHolo",5);
				//A_FireProjectile("D4HoloSpawner",0,0,0,0);
				A_SpawnItemEx("D4PlayerHolograph",40,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_SETMASTER);
			}
			A_GiveInventory("GrenadeCooldown",50);
		}
		D4GR A 0 A_OverlayFlags(GrenadeOverlay,PSPF_ADDWEAPON,0);
		D4GR A 0 A_OverlayOffset(GrenadeOverlay,0,0);
		D4GR AAA 1 A_OverlayOffset(GrenadeOverlay,20,10,WOF_ADD);
		D4GR BBB 1 A_OverlayOffset(GrenadeOverlay,20,10,WOF_ADD);
		Stop;
		
	//--------------------------------------------------------------
	//	Quick melee / Glory kill
	//--------------------------------------------------------------
	User2:
		"####" "#" 0 //before it does the regular punch, it checks if the Monster; is ready to be GK'd and if GK is ON
		{
			A_GiveInventory("BusyToken");
			
			if(countinv("FinisherToken",AAPTR_PLAYER_GETTARGET)>=1 && GetCvar("D4D_ExecutionAnimation")==1 && A_CheckLOF("Null",CLOFF_SETTARGET|CLOFF_NOAIM_VERT|CLOFF_IGNOREGHOST|CLOFF_MUSTBESOLID ,100))
			{ return ResolveState("ExecuteExecutions");	}

			return ResolveState(null);
		}
		
		"####" "##" 1 A_WeaponOffset(16,24,WOF_ADD);	//lowers weapon	
		"####" "#" 15 A_Overlay(PunchOverlay,"Overlay.Puncher");	//calls the punching hand
		"####" "###" 1 A_WeaponOffset(-11,-16,WOF_ADD);
		"####" "#" 0 
		{ 
			A_SetInventory("BusyToken",0);
			return ResolveState("Ready"); 
		}
		
	Overlay.Puncher:
		MELE A 0 
		{
			A_OverlayFlags(PunchOverlay,PSPF_ADDWEAPON,0);
		}
		MELE F 1 A_OverlayOffset(PunchOverlay,0,40);
		"####" "#" 0 A_Overlay(PunchSway,"Overlay.PunchSwayEffect");	//calls the punching swaying
		MELE F 4 
		{
			A_OverlayOffset(PunchOverlay,10,32);
			
			if(countinv("FinisherToken",AAPTR_PLAYER_GETTARGET)>=1)
			{
				A_CustomPunch(999999,1,0,"MeleePunchPuff",80,0,0,null,"Doom4/Weapon/Melee/Punch","Doom4/Other/MeleeSwing1");
			}
			else
			{	//if you have berserk, the quick melee will increase damage, but not as strong as the "fist weapon". This is to encourage to use the fist
				A_CustomPunch(countinv("PowerStrength")? random(50,100) : random(15,35),1,0,"FistPuff",80,0,0,null,"Doom4/Weapon/Melee/Punch","Doom4/Other/MeleeSwing1");
			}
		}
		MELE F 1 A_OverlayOffset(PunchOverlay,0,36);
		MELE F 1 A_OverlayOffset(PunchOverlay,-2,40);
		
		MELE E 1 A_OverlayOffset(PunchOverlay,-3,42);
		MELE E 1 A_OverlayOffset(PunchOverlay,-6,45);
		MELE E 1 A_OverlayOffset(PunchOverlay,-8,48);
		
		MELE D 1 A_OverlayOffset(PunchOverlay,-10,44);
		MELE D 1 A_OverlayOffset(PunchOverlay,-12,47);
		MELE D 1 A_OverlayOffset(PunchOverlay,-15,50) ;
		Stop;
	Overlay.PunchSwayEffect:
		W666 A 1 {  A_SetAngle(angle-1); A_SetRoll(-1.25,SPF_INTERPOLATE); A_SetPitch(pitch-0.5); }
		W666 A 1 {  A_SetAngle(angle-1); A_SetRoll(-2.5,SPF_INTERPOLATE); A_SetPitch(pitch-0.5); }
		W666 A 1 ;
		W666 A 1 ;
		W666 A 1 { A_SetAngle(angle+1); A_SetRoll(-1.5,SPF_INTERPOLATE); A_SetPitch(pitch+0.5); }
		W666 A 1 { A_SetAngle(angle+0.5); A_SetRoll(-0.75,SPF_INTERPOLATE); A_SetPitch(pitch+0.5); }
		W666 A 1 { A_SetAngle(angle+0.5); A_SetRoll(0,SPF_INTERPOLATE); }
		Stop;
	
	
		
	ExecuteExecutions:	//purposefully/purposely silly name
		"####" "##" 0 A_WeaponOffset(21,60,WOF_ADD);	//lowers weapon
		"####" "#" 1 A_CustomPunch(10000,1,0,"GloryKillPuff",150,0,0,null); //actually kills the Monster; without gibbing it
		"####" "#" 35 A_Overlay(PunchOverlay,"Overlay.Finisher");	//calls the animation
		"####" "###" 1 A_WeaponOffset(-7,-40,WOF_ADD);
		"####" "#" 0 
		{ 
			A_SetInventory("BusyToken",0);
			return ResolveState("Ready"); 
		}
	Overlay.Finisher:
		MELE A 0 A_Jump(256,"Finisher1","Finisher2","Finisher3");
		Goto Finisher2;
	Finisher1:
		"####" "#" 0 
		{
			A_GiveInventory("GloryKill1Token",1,TargetPtr);
			A_OverlayFlags(PunchOverlay,PSPF_ADDWEAPON,0);
			A_OverlayOffset(PunchOverlay,0,32);
			SetPlayerProperty(0,1,PROP_TOTALLYFROZEN); //player is made invulnerable, unshootable, unmovable and frozen for the duration of the Glory Kill
			A_UnsetShootable();
			if (!CountInv("PowerInvulBase") && !CountInv("PowerInvulnerable"))
			{	A_SetInvulnerable();	}
			A_Stop();
			bDONTTHRUST = true;
		}
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,50);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,40);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,30);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,-20,40);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,-40,50);
		MELE A 1 A_OverlayOffset(PunchOverlay,40,50);
		MELE B 1 { A_OverlayOffset(PunchOverlay,20,48); A_Playsound("Doom4/Other/MeleeSwing1",CHAN_BODY); }
		MELE C 1 A_OverlayOffset(PunchOverlay,0,40);
		MELE C 1 { A_OverlayOffset(PunchOverlay,-20,35); A_Playsound("Doom4/Weapon/Melee/Punch",CHAN_WEAPON); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-40,35); A_SetAngle(5+angle); A_SetRoll(-5); A_SetPitch(-3); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-60,35); A_SetAngle(5+angle); A_SetRoll(-10); A_SetPitch(-6); }
		MELE C 1 A_OverlayOffset(PunchOverlay,-80,60);
		MELE C 1 A_OverlayOffset(PunchOverlay,-100,80);
		MELE C 1 { A_OverlayOffset(PunchOverlay,-120,100);  A_SetAngle(-2+angle); A_SetRoll(-6); A_SetPitch(-4); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-140,120);  A_SetAngle(-2+angle); A_SetRoll(-3); A_SetPitch(-2); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-180,140);  A_SetAngle(-2+angle); A_SetRoll(0); A_SetPitch(0); }
		MELE C 1 A_OverlayOffset(PunchOverlay,-200,160);
		MELE G 1 A_OverlayOffset(PunchOverlay,20,80);
		MELE G 1 A_OverlayOffset(PunchOverlay,10,70);
		MELE H 1 { A_OverlayOffset(PunchOverlay,0,60); A_Playsound("Doom4/Other/MeleeSwing1",CHAN_BODY); }
		MELE H 1 { A_OverlayOffset(PunchOverlay,10,50);  A_SetRoll(3); A_SetPitch(1); }
		MELE I 1 { A_OverlayOffset(PunchOverlay,10,40);  A_SetRoll(6); A_SetPitch(2); }
		MELE I 1 { A_OverlayOffset(PunchOverlay,10,35); A_Playsound("Doom4/Weapon/Melee/Kick",CHAN_WEAPON); }
		MELE I 1 A_OverlayOffset(PunchOverlay,-10,36);
		MELE I 1 A_OverlayOffset(PunchOverlay,-12,40);
		MELE H 1 A_OverlayOffset(PunchOverlay,-13,48);
		MELE H 1 A_OverlayOffset(PunchOverlay,-16,45);
		MELE H 1 { A_OverlayOffset(PunchOverlay,-18,42);  A_SetRoll(4); A_SetPitch(2); }
		MELE G 1 { A_OverlayOffset(PunchOverlay,-20,50);  A_SetRoll(2); A_SetPitch(1); }
		MELE G 1 { A_OverlayOffset(PunchOverlay,-22,47);  A_SetRoll(0); A_SetPitch(0); }
		MELE G 1 A_OverlayOffset(PunchOverlay,-25,44);
		"####" "#" 0 
		{
			bDONTTHRUST = false;
			A_SetShootable();
			if (!CountInv("PowerInvulBase") && !CountInv("PowerInvulnerable"))
			{	A_UnSetInvulnerable();	}
			A_OverlayOffset(PunchOverlay,1,32); 
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN); 
		}
		Stop;
	Finisher2:	//double punch
		"####" "#" 0 
		{
			A_GiveInventory("GloryKill2Token",1,TargetPtr);
			A_OverlayFlags(PunchOverlay,PSPF_ADDWEAPON,0);
			A_OverlayOffset(PunchOverlay,0,32);
			SetPlayerProperty(0,1,PROP_TOTALLYFROZEN);
			A_UnsetShootable();
			if (!CountInv("PowerInvulBase") && !CountInv("PowerInvulnerable"))
			{	A_SetInvulnerable();	}
			A_Stop();
			bDONTTHRUST = true;
		}
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,50);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,40);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,30);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,-20,40);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,-40,50);
		MELE A 1 A_OverlayOffset(PunchOverlay,40,50);
		MELE B 1 { A_OverlayOffset(PunchOverlay,20,48); A_Playsound("Doom4/Other/MeleeSwing1",CHAN_BODY); }
		MELE C 1 A_OverlayOffset(PunchOverlay,0,40);
		MELE C 1 { A_OverlayOffset(PunchOverlay,-20,35); A_Playsound("Doom4/Weapon/Melee/Punch",CHAN_WEAPON); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-40,35); A_SetAngle(5+angle); A_SetRoll(-5); A_SetPitch(-3); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-60,35); A_SetAngle(5+angle); A_SetRoll(-10); A_SetPitch(-6); }
		MELE C 1 A_OverlayOffset(PunchOverlay,-80,60);
		MELE C 1 A_OverlayOffset(PunchOverlay,-100,80);
		MELE C 1 { A_OverlayOffset(PunchOverlay,-120,100); A_SetAngle(-2+angle); A_SetRoll(-6); A_SetPitch(-4); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-140,120); A_SetAngle(-2+angle); A_SetRoll(-3); A_SetPitch(-2); }
		MELE C 1 { A_OverlayOffset(PunchOverlay,-180,140); A_SetAngle(-2+angle); A_SetRoll(0); A_SetPitch(0); }
		MELE C 1 A_OverlayOffset(PunchOverlay,-200,160);
		MELE D 1 A_OverlayOffset(PunchOverlay,-40,50);
		MELE E 1 { A_OverlayOffset(PunchOverlay,-20,48); A_Playsound("Doom4/Other/MeleeSwing1",CHAN_BODY); }
		MELE F 1 A_OverlayOffset(PunchOverlay,0,40);
		MELE F 1 { A_OverlayOffset(PunchOverlay,20,35); A_Playsound("Doom4/Weapon/Melee/Punch",CHAN_WEAPON); }
		MELE F 1 { A_OverlayOffset(PunchOverlay,40,35); A_SetAngle(-5+angle); A_SetRoll(-5); A_SetPitch(-3); }
		MELE F 1 { A_OverlayOffset(PunchOverlay,60,35); A_SetAngle(-5+angle); A_SetRoll(-10); A_SetPitch(-6); }
		MELE F 1 A_OverlayOffset(PunchOverlay,80,60);
		MELE F 1 A_OverlayOffset(PunchOverlay,100,80);
		MELE F 1 { A_OverlayOffset(PunchOverlay,120,100); A_SetAngle(2+angle); A_SetRoll(-6); A_SetPitch(-4); }
		MELE F 1 { A_OverlayOffset(PunchOverlay,140,120); A_SetAngle(2+angle); A_SetRoll(-3); A_SetPitch(-2); }
		MELE F 1 { A_OverlayOffset(PunchOverlay,180,140); A_SetAngle(2+angle); A_SetRoll(0); A_SetPitch(0); }
		MELE F 1 A_OverlayOffset(PunchOverlay,200,160);
		"####" "#" 0 
		{
			bDONTTHRUST = false;
			A_SetShootable();
			if (!CountInv("PowerInvulBase") && !CountInv("PowerInvulnerable"))
			{	A_UnSetInvulnerable();	}
			A_OverlayOffset(PunchOverlay,1,32); 
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
		}
		Stop;
	Finisher3:
		"####" "#" 0 
		{
			A_GiveInventory("GloryKill3Token",1,TargetPtr);
			A_OverlayFlags(PunchOverlay,PSPF_ADDWEAPON,0);
			A_OverlayOffset(PunchOverlay,0,32);
			SetPlayerProperty(0,1,PROP_TOTALLYFROZEN);
			A_UnsetShootable();
			if (!CountInv("PowerInvulBase") && !CountInv("PowerInvulnerable"))
			{	A_SetInvulnerable();	}
			A_Stop();
			bDONTTHRUST = true;
		}
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,50);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,40);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,1,30);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,-20,40);
		MELE "[" 1 A_OverlayOffset(PunchOverlay,-40,50);
		MELE J 1 { A_OverlayOffset(PunchOverlay,1,40); A_SetAngle(3+angle); A_SetPitch(-2); }
		MELE J 1 { A_OverlayOffset(PunchOverlay,-5,0); A_SetAngle(3+angle); A_SetPitch(-4); A_Playsound("Doom4/Other/MeleeSwing1",CHAN_BODY); }
		MELE J 1 { A_OverlayOffset(PunchOverlay,-10,-40); A_SetAngle(3+angle); A_SetPitch(-8); }
		MELE J 4 { A_OverlayOffset(PunchOverlay,-25,-90); A_Playsound("Doom4/Weapon/Melee/Punch",CHAN_WEAPON); }
		MELE J 1 { A_OverlayOffset(PunchOverlay,-20,-60); A_SetAngle(-2+angle); A_SetPitch(-8); }
		MELE J 1 { A_OverlayOffset(PunchOverlay,-15,-30); A_SetAngle(-2+angle); A_SetPitch(-6); }
		MELE J 1 { A_OverlayOffset(PunchOverlay,-10,0); A_SetAngle(-2+angle); A_SetPitch(-4); }
		MELE J 1 { A_OverlayOffset(PunchOverlay,-5,30); A_SetAngle(-2+angle); A_SetPitch(-2); }
		MELE J 1 { A_OverlayOffset(PunchOverlay,1,60); A_SetAngle(-1+angle); A_SetPitch(0); }
		MELE "]" 1 A_OverlayOffset(PunchOverlay,1,42);
		MELE "]" 1 A_OverlayOffset(PunchOverlay,1,37);
		"####" "#" 0
		{
			bDONTTHRUST = false;
			A_SetShootable();
			if (!CountInv("PowerInvulBase") && !CountInv("PowerInvulnerable"))
			{	A_UnSetInvulnerable();	}
			A_OverlayOffset(PunchOverlay,1,32); 
			SetPlayerProperty(0,0,PROP_TOTALLYFROZEN);
		}
		Stop;
	}
}

Class BusyToken : Inventory { Default { Inventory.InterhubAmount 0; }}

Class FinisherToken : Inventory {}
Class GloryKill1Token : Inventory {}
Class GloryKill2Token : Inventory {}
Class GloryKill3Token : Inventory {}

Class GloryKillPuff : Actor 
{
	Default 
	{
		+NOINTERACTION
		+ALLOWTHRUFLAGS	//to ignore pinky's shield
		+THRUGHOST
		+PUFFGETSOWNER
		+PUFFONACTORS
		+NOTIMEFREEZE
		DamageType "GloryKill";
		+BLOODLESSIMPACT
		+NOEXTREMEDEATH
	}
	States
	{
	Spawn:
		TNT1 A 1 NoDelay A_GiveToTarget("PunchedAlready",1);
		Stop;
	}
}
Class MeleePunchPuff : Actor 
{
	Default 
	{
		DamageType "MeleePunch";
		-BLOODLESSIMPACT
		-NOEXTREMEDEATH
		+ALLOWTHRUFLAGS	//to ignore pinky's shield
		+THRUGHOST
		+PUFFGETSOWNER
		+PUFFONACTORS
		+NOTIMEFREEZE
	}
	
	override void PostBeginPlay()
	{
		Destroy();
	}
}

//=======================================================================
//=======================================================================
// "Give weapons" identifier
//=======================================================================
//=======================================================================

Class D4IdfaTrap : Weapon 
{
	Default 
	{
		Weapon.SlotNumber 0;
	}
	States 
	{ 
		Ready: Deselect: Select: Fire: TNT1 A 1 A_Lower;
	} 
}
Class IdfaStamp : Inventory {}

//=======================================================================
//=======================================================================
// Ledge grabbing hands
//=======================================================================
//=======================================================================

Class ClimbingHands : Weapon
{
	Default 
	{
		+WEAPON.CHEATNOTWEAPON
		+WEAPON.AMMO_OPTIONAL
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
		+INVENTORY.UNDROPPABLE
		+INVENTORY.UNTOSSABLE
		+Weapon.NOAUTOFIRE
	}
	States
	{
	Spawn:
		TNT1 A 0;
		Stop;
	Select:
		M666 A 0 A_Raise;
		Loop;
	Deselect:	
		M666 A 1;	//Needed.
	DesLoop:
		M666 A 0 A_Lower;
		Loop;
	Ready:
		TNT1 A 5 A_WeaponReady(WRF_NOFIRE|WRF_NOSWITCH);
		TNT1 A 1 A_WeaponReady(WRF_NOFIRE);
		Wait;
	Fire:
		M666 A 10;
		Goto Ready;
	}
}


//=======================================================================
//=======================================================================
// Impact Compensation
//=======================================================================
//=======================================================================

Class FallingHands : Weapon
{
	int UVeloz;
	int UVelooz;
	Default 
	{
		+WEAPON.CHEATNOTWEAPON
		+WEAPON.AMMO_OPTIONAL
		+WEAPON.NOAUTOFIRE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
		+INVENTORY.UNDROPPABLE
		+INVENTORY.UNTOSSABLE
	}
	States
	{
	Spawn:
		TNT1 A 0;
		Stop;
	Select:
		TNT1 A 0 A_Raise;
		Loop;
	Deselect:	
		TNT1 A 1;	//Needed.
	DesLoop:
		TNT1 A 0 A_Lower;
		Loop;
	Ready:
		TNT1 A 1 
		{
			if(pos.z != floorz)
			{
				A_SetPitch(pitch + frandom(1,2), SPF_INTERPOLATE);
			}
		}
		TNT1 A 0 A_JumpIf(pos.z == floorz, "Impact");
		Loop;
	Impact:
		TNT1 A 0 
		{
			if(pitch < 80) { A_SetPitch(80, SPF_INTERPOLATE); }
			A_Log("Impact Compensation.");
			A_PlaySound("Doom4/Player/Climb",7); // placeholder sound
			A_Overlay(Overlay_AnglePitch,"Visuals");
		}
		TNT1 A 25;
		TNT1 ABCDEFGH 1 A_SetPitch(pitch * 97 / 100 - frandom(0.1,1.0), SPF_INTERPOLATE);
		TNT1 ABCDEFGHIJKLMNOPQRSTUVWXYZ 1 A_SetPitch(pitch * 95 / 100 - frandom(0.5,1.5), SPF_INTERPOLATE);
		TNT1 ABCDEFGH 1 A_SetPitch(pitch * 90 / 100 - frandom(0.1,1.0), SPF_INTERPOLATE);
		TNT1 A 0 A_TakeInventory("FallingHands",0x7FFFFFFF);
		TNT1 A 0 A_SelectWeapon("D4Pistol");
		TNT1 A 0 A_WeaponReady;
	Visuals:
		PKFS F 25;
		PKFS EDCBA 8; // placeholder hands animation
		Stop;
	Fire:
		TNT1 A 0 A_SelectWeapon("D4Pistol");
		TNT1 A 0 A_WeaponReady;
		Goto Ready;
	}
}

Class FallingSpeed : Inventory { Default { Inventory.MaxAmount 0x7FFFFFFF; } }


//=======================================================================
//=======================================================================
// Doom doll
//=======================================================================
//=======================================================================
Class D4DoomDoll : CustomInventory
{
	Default 
	{
		Scale 0.3;
		Inventory.PickupMessage "Picked up a collectible doomguy!";
	}
	States
	{
	Spawn:
		DOLL A -1;
		Stop;
	PickUp:
		TNT1 A 0
		{
			if (CountInv("D4DoomDollHands"))
			{
				A_GiveInventory("DollUses",3);
			}
			else
			{
				A_GiveInventory("DollUses",4);
				ACS_NamedExecute("D4DoomDoll",0,0,0);
			}
		}
		Stop;
	}
}

Class DollUses : Inventory
{
	Default 
	{
		+INVENTORY.UNTOSSABLE
		+INVENTORY.UNDROPPABLE
		Inventory.InterhubAmount 10;
		Inventory.MaxAmount 10;
		Inventory.Amount 1;
	}
}

Class D4DoomDollPlaying : Inventory
{	Default { Inventory.InterHubAmount 0;	}}

Class D4DoomDollHands : Weapon
{
	Default 
	{
		+WEAPON.CHEATNOTWEAPON
		+WEAPON.AMMO_OPTIONAL
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
		+INVENTORY.UNDROPPABLE
		+INVENTORY.UNTOSSABLE
		+WEAPON.NOAUTOFIRE
	}
	States
	{
	Spawn:
		TNT1 A 0;
		Stop;
	Select:
		M666 A 0 
		{
			A_OverlayFlags(PSP_WEAPON, PSPF_POWDOUBLE, false);
			A_Raise(20000);
		}
		Loop;
	Deselect:	
		M666 A 1;	//Needed.
	DesLoop:
		M666 A 0 A_Lower;
		Loop;
	Ready:
		TNT1 A 0 
		{
			A_GiveInventory("DollBuddha");
			if (CountInv("D4DoomDollUpgrade1"))
			{
				A_GiveInventory("DollSpeed");
				A_GiveInventory("DollJump");
			}
			A_Overlay(200, "Overlay.BroFist");
			
		}
		TNT1 A 1;
		Wait;
	Overlay.BroFist:
		TNT1 AAAA 1 
		{
			int OID = OverlayID();
			A_OverlayFlags(OID, PSPF_POWDOUBLE, false);
			A_OverlayOffset(OID,-8,20,WOF_ADD);
		}
		DDLL AAAAAAAA 1 A_OverlayOffset(OverlayID(),4,-10,WOF_ADD);
		DDLL A 70;
		DDLL BCDEE 1 ;
		"####" F 1
		{
			if (CountInv("D4DoomDollUpgrade2"))
			{
				A_SpawnItemEx("DollExplosion",flags: SXF_NOCHECKPOSITION);
				bFORCERADIUSDMG = bFOILINVUL = true;
				A_Explode(2048, 1024, XF_NOTMISSILE, false, 512);
				bFORCERADIUSDMG = bFOILINVUL = false;
			}
			A_GiveInventory("DollProtection");
			A_GiveInventory("DollPush");
			A_GiveInventory("D4MegaSphereNoBonus");
			if (CountInv("D4RegenUpgrade4") && health < 300)
			{	A_SetHealth(300);	}
			A_TakeInventory("DollUses",1,0);
			A_SpawnItemEx("BroFistPuff",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION);
		}
		DDLL FFFF 1;
		DDLL GHIJKLMNOPQRSTUVWXYZ 2;
		DDL2 ABCDEFGHI 2;
		DDLL AAAAAAAA 1 A_OverlayOffset(OverlayID(),-14,20,WOF_ADD);
		TNT1 A 5 ;
		TNT1 A 10000; //just to ensure it wont play again while the script takes it away
		Wait;
	Fire:
		M666 A 1;
		Goto Ready;
	}
}

Class BroFistPuff : Actor 
{
	Default 
	{
	+NOINTERACTION
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay
		{
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);
			A_SpawnItemEx("BruiserDustCloud",0,0,0,frandom(-6,6),frandom(-6,6),0,0,SXF_NOCHECKPOSITION);

		}
		TNT1 A 10;
		Stop;
	}
}

Class DollExplosion : Actor
{
	Default
	{
		+NOINTERACTION
		+NOBLOCKMAP
		+NOSECTOR
	}
	States
	{
	Spawn:
		TNT1 A 200 NoDelay A_PlaySound("Doom4/Other/DollExplode",CHAN_WEAPON,1,0,ATTN_NONE);
		Stop;
	}
}

Class DollProtBase : PowerProtection
{
	Default 
	{
		DamageFactor "Normal", 0.05;	//takes a tiny bit of damage
	}
}

Class DollProtection : PowerupGiver
{
	Default 
	{
		powerup.duration -8;
		+INVENTORY.QUIET
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.UNDROPPABLE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
		Powerup.Type "DollProtBase";
	}
	States
	{
	Spawn:
		MEGA A 4 Bright;
		Loop;
	}
}

Class DollPush : ArtiBlastRadius
{
	Default 
	{
		+INVENTORY.QUIET
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.UNDROPPABLE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
	}
	States
	{
	Spawn:
		MEGA A 4 Bright;
		Loop;
	}
}

Class DollBuddha : PowerupGiver
{
	Default 
	{
		+INVENTORY.QUIET
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
		+INVENTORY.UNDROPPABLE
		Powerup.Type "PowerBuddha";
		Powerup.Duration 170;
	}
}

Class DollSpeed : PowerupGiver
{
	Default 
	{
		+INVENTORY.QUIET
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
		+INVENTORY.UNDROPPABLE
		Powerup.Type "PowerSpeed";
		Powerup.Duration 170;
	}
}

Class DollJump : PowerupGiver
{
	Default 
	{
		+INVENTORY.QUIET
		+INVENTORY.AUTOACTIVATE
		+INVENTORY.ALWAYSPICKUP
		+INVENTORY.NOSCREENFLASH
		+INVENTORY.UNDROPPABLE
		Powerup.Type "PowerHighJump";
		Powerup.Duration 170;
	}
}


//=======================================================================
//=======================================================================
// Casings
//=======================================================================
//=======================================================================

Class BulletCasing : Actor 
{
	Default 
	{
	Projectile;
	-NOGRAVITY
	Radius 4;
	Height 2;
	+THRUACTORS
	Gravity 0.7;
	Scale 0.15;
	Bouncetype "doom";
	BounceFactor 0.5;
	+FORCEXYBILLBOARD
	BounceSound "Doom4/Weapon/BulletCasing";
	}
	States
	{
	Spawn:
		CSNG AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPP 1; //A_SpawnParticle("696969",0,random(20,40),random(1,2),0,0,0,0,0,0,frandom(0.1,0.6))
		Loop;
	Death:
		"####" "#" 100
		{
			if (GetCvar("D4D_ShortCasingLives")) { return ResolveState("Null"); }
			return ResolveState(null);
		}
		Stop;
	}
}

Class BulletCasingSilent : BulletCasing
{	Default { BounceSound ""; }}

Class ShellCasing : Actor 
{
	Default 
	{
	Projectile;
	-NOGRAVITY
	Radius 4;
	Height 2;
	+THRUACTORS
	Gravity 0.7;
	Scale 0.22;
	Bouncetype "doom";
	BounceFactor 0.5;
	+FORCEXYBILLBOARD
	BounceSound "Doom4/Weapon/ShellCasing";
	}
	States
	{
	Spawn:
		SHLL AABBCCDDEEFFGGHHIIJJKKLLMMNNOOPP 1; //A_SpawnParticle("696969",0,random(20,40),random(1,2),0,0,0,0,0,0,frandom(0.1,0.6))
		Loop;
	Death:
		"####" "#" 100
		{
			if (GetCvar("D4D_ShortCasingLives")) { return ResolveState("Null"); }
			return ResolveState(null);
		}
		Stop;
	}
}

Class ShellCasingSilent : ShellCasing
{	Default { BounceSound ""; }}



//=======================================================================
//=======================================================================
// Tracers
//=======================================================================
//=======================================================================

Class NonPuff2 : Actor
{
	Default
	{
		+NOINTERACTION
		+PAINLESS
		+BLOODLESSIMPACT
		+NOTIMEFREEZE
		+NOBLOCKMAP
		+PUFFONACTORS
		+SKYEXPLODE
		+HITTRACER
		Radius 1;
		Height 1;
		Renderstyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 15;
		Stop;
	}
}

Class NonPuff : Actor
{
	Default
	{
		+NOINTERACTION
		+PAINLESS
		+BLOODLESSIMPACT
		+NOTIMEFREEZE
		+NOBLOCKMAP
		+ALWAYSPUFF
		+PUFFONACTORS
		+SKYEXPLODE
		+HITTRACER
		Radius 1;
		Height 1;
		Renderstyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 3;
		Stop;
	}
}

Class NonPuffThru : NonPuff
{
	Default
	{
		+ALLOWTHRUFLAGS
		+THRUACTORS
	}
}

Class PistolTracerNormal : FastProjectile
{
	Default 
	{
		Projectile;
		+RANDOMIZE
		+FORCEXYBILLBOARD
		+DONTSPLASH
		+NOEXTREMEDEATH
		+NOTIMEFREEZE
		damage 0;
		radius 2;
		height 2;
		speed 200;
		RenderStyle "Add";
		alpha 0.9;
		scale 0.2;
		Translation "0:255=%[0,0,0]:[0.5,0.65,1.5]";
	}
	states
	{
	Spawn:
		TRAC A 10 BRIGHT;
		Stop;
	Death:
		TNT1 A 1;
		Stop;
	XDeath:
		TNT1 A 1;
		Stop;
	}
}

Class PistolTracerRed : FastProjectile
{
	Default 
	{
		Projectile;
		+RANDOMIZE
		+FORCEXYBILLBOARD
		+DONTSPLASH
		+NOEXTREMEDEATH
		+NOTIMEFREEZE
		damage 0;
		radius 2;
		height 2;
		speed 200;
		RenderStyle "Add";
		alpha 0.9;
		scale 0.2;
		Translation "0:255=%[0,0,0]:[1.5,0,0]";
	}
	states
	{
	Spawn:
		TRAC A 10 BRIGHT;
		Stop;
	Death:
		TNT1 A 1;
		Stop;
	XDeath:
		TNT1 A 1;
		Stop;
	}
}

Class BulletSmallTracer : Actor
{
	Actor Puff;
	bool DestroyMe, HadPuff, FirstTic;
	double Dist;
	double _cos, _sin;
	const RealSpeed = 200.0;
	Default 
	{
		Projectile;
		+RANDOMIZE
		+FORCEXYBILLBOARD
		+DONTSPLASH
		+NOEXTREMEDEATH
		+NOTIMEFREEZE
		+PAINLESS
		+BLOODLESSIMPACT
		+NODAMAGETHRUST
		+NOINTERACTION
		damage 0;
		radius 2;
		height 2;
		speed 0;
		RenderStyle "Add";
		alpha 0.9;
		scale 0.13;
		//Translation "0:255=%[0,0,0]:[0,1,1.5]";
	}
	override void OnDestroy()
	{
		if (Puff)	Puff.Destroy();
		Super.OnDestroy();
	}
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		if (Tracer)
		{
			HadPuff = true;
			Dist = Distance3DSquared(Tracer);
		}
		else	Dist = -1.0;
		
		_cos = cos(pitch) * RealSpeed;
		_sin = -sin(pitch) * RealSpeed;
	}
	
	override void Tick()
	{		
		if (DestroyMe)	
			return Super.Tick();
			
		if (!bNOTIMEFREEZE && (globalfreeze || level.frozen))
			return Super.Tick();
		
		//vel = (0,0,0);
		//A_Stop();
		Puff = (Tracer) ? Tracer : LineAttack(angle, RealSpeed + 1, pitch, -1, '', "NonPuff2", LAF_NOINTERACT);
		if (Puff)
		{
			double CurDist = Distance3DSquared(Puff);
			if (CurDist <= (RealSpeed ** 2))
			{
				//Speed = sqrt(CurDist);
				double root = sqrt(CurDist);
				DestroyMe = true;
				A_Stop();
				Warp(self, cos(pitch) * root, 0, -sin(pitch) * root, flags: WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE);
				ExplodeMissile(null, null);
				return Super.Tick();
			}
		}
	//	Vel3DFromAngle(200.0, angle, pitch);
		Warp(Self, _cos, 0, _sin, 0, WARPF_NOCHECKPOSITION|WARPF_INTERPOLATE);
		Super.Tick();
	}
	
	States
	{
	Spawn:
		TRAC A 10 BRIGHT;
		Stop;
	Death:
		TNT1 A 1;
		Stop;
	XDeath:
		TNT1 A 1;
		Stop;
	}
}


Class D4AbstractMissile : Actor 
{
	bool HQ;
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		HQ = GetCvar("HQEffects");		
		if (Target && Target.bISMONSTER)
		{
			if (Target.Species == 'DemonPlayerBase')
			{
				Species = Target.Species;
				bTHRUSPECIES = bMTHRUSPECIES = true;
			}
		}
	}
}

Class D4AbstractMissilePlayer : D4AbstractMissile
{
	override void PostBeginPlay()
	{
		Actor.PostBeginPlay();
		HQ = GetCvar("HQEffectsWeapons");
	}
}

Class D4AbstractMissileQuake : D4AbstractMissile
{
	transient CVar QuakeC;
	bool DoQuake;
	
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		
		QuakeC = CVar.FindCvar("D4D_quakexplosions");
		if (QuakeC)	DoQuake = QuakeC.GetBool();
	}
}


//------------------------------------------------------------------------------
//	
// The following code is courtesy of phantombeta, which can be found here:
// https://github.com/Doom2fan/Se7evidas/blob/master/PK3%20Source/S7ZScript/Bases/Base%20Actors.ZS
//
// Further modifications by Major Cooke
// 
// Projectile bases
// 
//------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------
//
// Misc bases
//
//-------------------------------------------------------------------------------------------
/** Monster spawner base
*** Usage: Works exactly like RandomSpawner, except you can override MS_GetMonsterSpawnList to change the spawner's behaviour.
*** Virtuals:
***     void PostSpawn (Actor spawned): Called when the actor is finished spawning. (From RandomSpawner)
***     DropItem MS_GetMonsterSpawnList (): called when getting the monster spawn list. (From D4D_MonsterSpawner)
**/


/** Trace test puffs **/
class D4D_TraceTestPuff : Actor 
{
    default 
	{
        Radius 1;
        Height 1;
        +NOBLOCKMAP +ALLOWTHRUFLAGS +NOINTERACTION +NOTIMEFREEZE
        +BLOODLESSIMPACT +PAINLESS
    }

    States 
	{
    Spawn:
    Death:
        TNT1 A 1;
        stop;
    }
}

class D4D_WallCheckPuff : D4D_TraceTestPuff 
{	default {	+THRUACTORS	}	}

//-------------------------------------------------------------------------------------------
//
// Projectile base
//
//-------------------------------------------------------------------------------------------
class D4D_Projectile_Trace : LineTracer 
{
    D4D_Projectile sourceActor;
    Array<Actor> actorsToIgnore;
    
    override ETraceStatus TraceCallback() 
	{
        /*if (!sourceActor)
            return TRACE_Skip;*/

        switch (Results.HitType) 
		{
            case TRACE_HitActor:
                if (sourceActor.bThruActors)
                    return TRACE_Skip;

                let mo = Results.HitActor;
				
				if (actorsToIgnore.Size() > 0)
				{
					for (int i = 0; i < actorsToIgnore.Size(); i++) 
					{
						if (mo == actorsToIgnore [i])
							return TRACE_Skip;
					}
				}
                if (mo != sourceActor && (sourceActor.bMissile && mo != sourceActor.target)) 
				{
                    if (!(mo.bSolid || mo.bSpecial || mo.bShootable || mo.bTouchy))
                        return TRACE_Skip;
                    if (mo.bThruActors)// || (sourceActor.bThruSpecies && mo.GetSpecies () == sourceActor.GetSpecies ()))
                        return TRACE_Skip;

                    return TRACE_Stop; // && sourceActor.CanCollideWith (Results.HitActor)
                } 
				else
                    return TRACE_Skip;
            break;

            case TRACE_HitFloor:
            case TRACE_HitCeiling:
                return TRACE_Stop;
            break;

            case TRACE_HitWall:
                if (Results.Tier == TIER_Upper || Results.Tier == TIER_Lower) return TRACE_Stop;

                let hl = Results.HitLine;
                if (sourceActor.bMissile && (hl.flags & (Line.ML_BLOCKPROJECTILE | Line.ML_BLOCKEVERYTHING)))
                    return TRACE_Stop;
                
                if (sourceActor.bMissile && Results.Tier == TIER_Middle && (hl.flags & Line.ML_BLOCKING) && (hl.flags & Line.ML_TWOSIDED))
                    return TRACE_Skip;
                
                if ((hl.flags & Line.ML_BLOCKING) || (hl.flags & Line.ML_BLOCKEVERYTHING) || (sourceActor.bIsMonster && (hl.flags & Line.ML_BLOCKMONSTERS)))
                    return TRACE_Stop;
            break;
        }
        return TRACE_Skip;
    }
}

/// The base type for all fast projectiles
class D4D_Projectile : FastProjectile 
{
    enum EMovementMode 
	{
        Normal = 0, /// The projectile uses the normal movement code.
        FastProjectile, /// The projectile is a FastProjectile.
        OldFastProj, /// The projectile is a FastProjectile and uses GZDoom's code.
    };
    /// Determines how to detect collisions. Only used for EMovementMode.FastProjectile.
    enum EFPCollisionMode 
	{
        ColMode_Center      = 1, /// Check the center for collision
        ColMode_Corners     = 1 << 1, /// Check the corners for collision
        ColMode_EdgeCenters = 1 << 2, /// Check the center of the edges for collision.
    };
	private bool exploded;
    int moveMode;
    int fpCollisionMode;
    bool interpFastProj;
    double effectStepMul;

    /// Which movement code to use.
    property MovementMode: moveMode;
    /// How to detect collisions. Only used by EMovementMode.FastProjectile.
    property FastProjCollision: fpCollisionMode;
    /// Changes how many times StepEffects is called. Only used by EMovementMode.FastProjectile.
    property EffectStepMul: effectStepMul;
    /// Whether to interpolate the projectile's movement. Only used by EMovementMode.FastProjectile.
    property InterpMove: interpFastProj;

    Default 
	{
		//D4D_Projectile.MovementMode FastProjectile;
		D4D_Projectile.FastProjCollision ColMode_Center;
		D4D_Projectile.InterpMove true;
		D4D_Projectile.EffectStepMul 0.125;
        Projectile;
    }

    transient D4D_Projectile_Trace tr;

	
	override void Tick() 
	{
		if (exploded)	return Actor.Tick();
		
		if (!self)
            return;

        ClearInterpolation();
        let oldPos = pos;
        let oldVel = vel;

        if (!bNoTimeFreeze && (globalfreeze || level.Frozen))
            return;

        if (vel != (0, 0, 0) || (pos.Z != floorz)) 
		{	// Create a tracer
            if (!tr) 
			{
				tr = new ("D4D_Projectile_Trace"); 
				tr.sourceActor = self; 
			}
            tr.actorsToIgnore.Clear();

            if (bMissile && vel.X == 0 && vel.Y == 0 && !IsZeroDamage())
                vel.X = MinVel;

            let velUnit = vel.Unit();
            double velAngle = VectorAngle(velUnit.x, velUnit.y);
            double s = sin (velAngle);
            double c = cos (velAngle);

            double maxDist = abs(vel.Length());
            int colFlags = (fpCollisionMode & (ColMode_Center | ColMode_Corners | ColMode_EdgeCenters));
            int iMax = FPColOffs.Size () / 2;

            int loopBreaker = 0;
            bool collisionHandled = false;
            for (int i = 0; i < iMax; i++) 
			{
					 if ((i >= 0 && i <= 3) && 	!(colFlags & ColMode_EdgeCenters))
                    continue;
                else if ((i >= 4 && i <= 7) && 	!(colFlags & ColMode_Corners))
                    continue;
                else if ((i == 8) && 			!(colFlags & ColMode_Center))
                    continue;

                tr.actorsToIgnore.Clear();

                do 
				{
                    double yOffs = radius * FPColOffs [i * 2];

                    if (tr.Trace(Vec3Offset(s * yOffs, c * yOffs, height * FPColOffs [i * 2 + 1]), curSector, velUnit, maxDist, 0)) 
					{
                        if (!self)
                            return;

						if (HandleCollision(oldPos, oldVel)) 
						{
							if (!self)
								return;

							tr.actorsToIgnore.Clear();
							collisionHandled = true;
							break;
						}
                    } 
					else
                        tr.actorsToIgnore.Clear();

                    loopBreaker++;
                    if (loopBreaker >= 10000) 
					{ // Uh oh.
                        //Console.PrintF ("Broke an infinite loop.");
						exploded = true;
                        Destroy();
                        return;
                    }
                } 
				while (tr.actorsToIgnore.Size() > 0);

                if (collisionHandled)
                    break;
            }

            if (!collisionHandled)
                SetOrigin(pos + vel, true);
            TryMove(pos.xy, true, false);
			
			class<Actor> trail = MissileName;
			if (trail && !exploded)
				SpawnEffects(oldPos, level.Vec3Diff (pos, oldPos).Length (), oldVel);

            if (!collisionHandled) 
			{
                bool floorHit = pos.Z <= floorZ;
                bool ceilingHit = (pos.Z + height) > ceilingZ;

                bool hitSky = ((  floorHit &&   floorpic == skyflatnum) ||
                               (ceilingHit && ceilingpic == skyflatnum));
				
                if (hitSky && !bSkyExplode) 
				{
					exploded = true;
					A_Stop();
                    Destroy();
                    return;
                } 
				else if (floorHit || ceilingHit) 
				{
                    SetZ(floorHit ? GetZAt() : ceilingZ - height);

                    if (floorHit)
                        HitFloor();

                    A_Stop();
                    if (bMissile)
					{
						exploded = true;
                        ExplodeMissile (NULL, NULL, hitsky);
					}
                }
            }

            vel.z += GetGravity ();

            UpdateWaterLevel ();
            CheckPortalTransition ();
        }

        // Nope the fuck out if self is null for some retarded reason, or freed itself
        if (!self || !CheckNoDelay())
            return;
			
        // Advance the state
        if (tics != -1) 
		{
            if (tics > 0)
                tics--;

            while (!tics) 
			{
                if (!self || !CurState || !SetState(CurState.NextState)) // mobj was removed
                    return;
            }
        }
	}

    virtual Actor StepEffects (Vector3 initialPos, Vector3 stepDiff, Vector3 realVel) 
	{
        class<Actor> trail = MissileName;

        if (trail) 
		{
            Vector3 finalPos = initialPos + stepDiff;

            Actor act = Spawn (trail, initialPos, ALLOW_REPLACE);
            act.SetOrigin (finalPos, false);

            double realFloorZ = GetZAt (finalPos.X, finalPos.Y, flags: GZF_AbsolutePos | GZF_AbsoluteAng);

            double hitz = finalPos.z - 8;
            if (hitz < realFloorZ)
                hitz = realFloorZ;
            // Do not clip this offset to the floor.
            hitz += missileHeight;

            act.SetOrigin ((finalPos.xy, hitz), false);

            if (act) 
			{
                if (bGetOwner && target)
                    act.target = target;
                else
                    act.target = self;
                
                act.angle = angle;
                act.pitch = pitch;
            }
            return act;
        }
        return null;
    }

    void SpawnEffects (Vector3 initialPos, double dist, Vector3 stepSize) 
	{
        if (radius <= 0 || dist <= 0 || exploded)
            return;

        int count = 8;
        while (abs (stepSize.X) > radius * count || abs (stepSize.Y) > radius * count)
            count += count;

        Vector3 frac = stepSize / count;

        int spawnCount = int (count * effectStepMul);
        for (int i = 0; i < count; i++) 
		{
            double diff = abs ((frac * i).Length ());

            if (diff >= dist)
                break;

            if (--spawnCount <= 0) 
			{
                spawnCount = int (count * effectStepMul);
                StepEffects (initialPos, frac * i, stepSize);
            }
        }
    }

	//--------------------------------------------------------------------------
	// Offsets based on Y and Z instead of X and Y
    static const double FPColOffs[] = 
	{ 
        // Edge centers
         0, 1.0,
         1, 0.5,
         0, 0.0,
        -1, 0.5,
        // Corners
         1, 1,
         1, 0,
        -1, 0,
        -1, 1,
        // Center
        0, 0.5
    };
	
    virtual void NewFastProjTick() 
	{
        
    }

    bool HandleCollision(Vector3 oldPos, Vector3 oldVel) 
	{
        if (abs(level.Vec3Diff(oldPos, tr.Results.hitPos).Length()) > abs (oldVel.Length()) + radius) 
		{
            if (tr.Results.HitType == TRACE_HitActor && tr.Results.HitActor)
                tr.actorsToIgnore.Push(tr.Results.HitActor);

            return false;
        }

        double maxDist = abs(oldVel.Length());
        double hitPosDist = abs(tr.Results.hitPos.Length());
        let hitPos = tr.Results.HitPos;
        hitPos += -(oldVel.Unit() * abs (radius));

        SetOrigin (hitPos, interpFastProj);

        if (!bSKYEXPLODE) 
		{
            if (tr.Results.HitType == TRACE_HitWall && tr.Results.HitLine) 
			{
                let l = tr.Results.HitLine;
                if (l.backsector && l.backsector.GetTexture (sector.ceiling) == skyflatnum) 
				{
                    let posr = PosRelative (l.backsector);
                    if (pos.Z >= l.backsector.ceilingplane.ZatPoint (posr.XY)) 
					{
                        // Hack to prevent missiles exploding against the sky.
                        // Does not handle sky floors.
                        SpawnEffects (oldPos, tr.Results.Distance, oldVel);
                        Destroy();
                        return true;
                    }
                }

                // [RH] Don't explode on horizon lines.
                if (l && l.special == Line_Horizon) 
				{
                    SpawnEffects (oldPos, tr.Results.Distance, oldVel);
                    Destroy();
                    return true;
                }
            } 
			else if ((tr.Results.HitType == TRACE_HitFloor && floorpic == skyflatnum) ||
                (tr.Results.HitType == TRACE_HitCeiling && ceilingpic == skyflatnum)) 
			{
                SpawnEffects (oldPos, tr.Results.Distance, oldVel);
                Destroy();
                return true;
            }
        }

        if (tr.Results.HitType == TRACE_HitFloor)
            hitPos = tr.Results.HitPos;
        else if (tr.Results.HitType == TRACE_HitCeiling) {
            hitPos = tr.Results.HitPos;
            hitPos -= (0, 0, height);
        }

        Vector3 rHitPos = tr.Results.HitPos;

        double realFloorZ = GetZAt(rHitPos.X, rHitPos.Y, flags: GZF_AbsolutePos | GZF_AbsoluteAng);
        double realCeilingZ = GetZAt(rHitPos.X, rHitPos.Y, flags: GZF_AbsolutePos | GZF_AbsoluteAng | GZF_Ceiling);

        bool floorHit = (rHitPos.Z <= realFloorZ || rHitPos.Z ~== realFloorZ);
        bool ceilingHit = (rHitPos.Z + height) > realCeilingZ;

        FCheckPosition tm;
        tm.DoRipping = bRipper;

        if (!TryMove(hitPos.XY + (double.epsilon * 3, double.epsilon * 3), true, tm: tm)) 
		{
            SetOrigin(hitPos, interpFastProj);

            bool hitSky = ((  floorHit &&   floorpic == skyflatnum) ||
                           (ceilingHit && ceilingpic == skyflatnum));

            A_Stop();
            ExplodeMissile(BlockingLine, BlockingMobj, (!BlockingLine && !BlockingMobj) ? hitSky : false);
			exploded = true;
            return true;
        } 
		else if (tr.Results.HitType == TRACE_HitActor && tr.Results.HitActor)
            tr.actorsToIgnore.Push (tr.Results.HitActor);
        else 
		{
            if ((tr.Results.HitType == TRACE_HitFloor && floorHit) ||
                (tr.Results.HitType == TRACE_HitCeiling && ceilingHit)) 
			{
                SetOrigin(hitPos, interpFastProj);

                bool hitSky = ((  floorHit &&   floorpic == skyflatnum) ||
                               (ceilingHit && ceilingpic == skyflatnum));

                if (tr.Results.HitType == TRACE_HitFloor) 
				{
                    SetZ(floorZ);
                    HitFloor();
					exploded = true;
                }

                if (bMissile) 
				{
					exploded = true;
                    A_Stop();
                    ExplodeMissile(NULL, NULL, hitSky);
                }

                return true;
            }
		//	else if (D4D_DebugMode >= 1)
		//		Console.PrintF ("zzz %f ----- %f, %d", rHitPos.Z, GetZAt (rHitPos.X, rHitPos.Y, flags: GZF_AbsolutePos | GZF_AbsoluteAng), floorHit);
        }

        SetOrigin(oldPos, false);
        return false;
    }
}