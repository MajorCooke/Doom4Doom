// AkimboWeapon's Functions
// Separated to keep things clean.

extend Class AkimboWeapon
{
	const TurretOffX = 5;
	//const TurretOffXLeft = 187;
	const TurretOffY = -72;
	// For the Super Shotgun.
	enum SuperShotgun
	{
		DmgBase = 		5,
		DmgMulMin = 	1,
		DmgMulMax = 	3,
		FCMFlags =		FPF_NOAUTOAIM,
	};
	const SpreadXY = 11.2;
	const SpreadZ = 7.1;
	//--------------------------------------------------------------------------
	enum InputTrans
	{
		PLeft = 	BT_ATTACK,
		PRight = 	BT_ALTATTACK,
		ALeft =		BT_USER1,
		ARight =	BT_RELOAD
	};
	enum AkimboStuff
	{
		TotalWeapons = 14,
		WEAP_NEXT = 1,
		WEAP_PREV = -1,
		
		StartIndex = 1
	};
	
	static const int WeapOffset[] =
	{
		0,			0,		// Leave 0,0 always!
		0,			0,		// Pistol
		0,			0,		// Shotgun
		0,			0,		// SSG
		20,			20,		// Repeater
		20,			20,		// HAR HAR HAR!
		40,			40,		// Chaingun
		0,			0,		// Rocket Launcher
		0,			0,		// Plasma Rifle
		5,			5,		// Lightning Gun
		30,			20,		// Gauss Cannon
		0,			0,		// Vortex Rifle
		0,			0,		// Static Rifle
		0,			0,		// Carrion Cannon
		60,			-33		// Bee Eff Gee
	};
	/*
	static const int LeftOffset[] =
	{
		0,			0,		// Leave 0,0 always!
		-200 - 0,	0,		// Pistol
		-200 - 0,	0,		// Shotgun
		-170 - 0,	0,		// SSG
		-160 - 20,	20,		// Repeater
		-262 - 20,	20,		// HAR HAR HAR!
		-70  - 40,	40,		// Chaingun
		-293 - 0,	0,		// Rocket Launcher
		-140 - 0,	0,		// Plasma Rifle
		-165 - 5,	5,		// Lightning Gun
		-90  - 30,	20,		// Gauss Cannon
		-150 - 0,	0,		// Vortex Rifle
		-220 - 0,	0,		// Static Rifle
		-198 - 0,	0,		// Carrion Cannon
		-340  - 0,	-33		// Bee Eff Gee I Gots 2 Pee
	};
	*/
	
	static const int LeftOffset[] =
	{
		0,			0,		// Leave 0,0 always!
		-200,		0,		// Pistol
		-200,		0,		// Shotgun
		-170,		0,		// SSG
		-180,		20,		// Repeater
		-282,		20,		// HAR HAR HAR!
		-110,		40,		// Chaingun
		-293,		0,		// Rocket Launcher
		-140,		0,		// Plasma Rifle
		-170,		5,		// Lightning Gun
		-90,		20,		// Gauss Cannon
		-150,		0,		// Vortex Rifle
		-220,		0,		// Static Rifle
		-198,		0,		// Carrion Cannon
		-340,		-33		// Bee Eff Gee
	};
	
	//==========================================================================
	// Sound Management
	//==========================================================================
	/*
	action void PlaySound(sound whattoplay = "weapons/pistol", int slot = CHAN_BODY, double volume = 1.0, bool looping = false, double attenuation = ATTN_NORM, bool local = false, double pitch = 0.0)
	{
		let i = invoker; let o = i.owner; if (!o)	return;
		int flag = (looping) ? CHANF_LOOP : 0;
		o.A_StartSound(whattoplay, slot, flag, volume, attenuation, pitch);
	}
	
	action void AkPlaySound(Sound snd, int slot = CHAN_BODY, double volume = 1.0, bool looping = false, int attenuation = ATTN_NORM, bool local = false, int id = 0)
	{
		if (!id) id = OverlayID();
		int who = (id < 0) ? Left : Right;
		
		if (who < 0 || who > invoker.SoundMaker.Size())	return;
		
		int flag = (looping) ? CHANF_LOOP : 0;
		invoker.SoundMaker[who].A_StartSound(snd,slot,volume,looping,attenuation,local);
	}
	
	action void AkStopSound(int chmin, int chmax = -1, int id = 0)
	{
		if (!id) id = OverlayID();
		int who = id < 0 ? 0 : 1;
		
		if (invoker.SoundMaker[who])
		{
			if (chmax > 0 && (chmin > chmax))
			{
				int temp = chmin;
				chmin = chmax;
				chmax = temp;
			}
			
			if (chmax < 0)
				invoker.SoundMaker[who].A_StopSound(chmin);
			
			else
				for (int i = chmin; i <= chmax; i++)
					invoker.SoundMaker[who].A_StopSound(chmin);		
		}
	}
	*/
	//==========================================================================
	// State/Status Management
	//==========================================================================
	//
	//--------------------------------------------------------------------------
	// Adjust Haste 
	//
	// Adjusts tics based on 
	//--------------------------------------------------------------------------
	
	action void AdjustHaste(int newtic = -1)
	{
		if (FindInventory("PowerDoubleFiringSpeed", true) != null)
		{
			let plr = invoker.owner.player;
			if (!plr) return;
			
			// Grab the player sprite (aka the overlay).
			
			let psp = plr.FindPSprite(OverlayID());
			if (psp)
			{
				// Adjust the tics based on the following rules:
				//
				if (newtic > -1)				psp.Tics = newtic;
				else if (psp.Tics == 1)			psp.Tics = 0;
				else if (psp.Tics <= 0)			return;
				//else if ((psp.Tics % 2) == 1)	psp.Tics = Max(0,((psp.Tics / 2) - 1));
				else							psp.Tics /= 2;
			}
		}
	}
	
	action void AkSpriteFrame(String spr = '', int fr = -1, int id = 0)
	{
		int len = spr.Length();
		if (len != 4 && fr < 0)	
		{
			if (len > 0)
				Console.Printf("Sprite must be 4 characters long!");
			return;
		}
		
		if (spr == "----") return;
		
		if (!id) id = OverlayID();
		
		// Don't do anything if invalid player or psprite.
		let plr = invoker.owner.player;
		if (!plr) return;
		
		let psp = plr.FindPSprite(id);
		if (!psp) return;
		
		// Make sure the length is correct.
		if (len > 0)
		{
			if (len == 4)
			{
				if (spr != '####' && spr != '----')
					psp.Sprite = GetSpriteIndex(spr);
			}
			else
			{
				Console.Printf("Sprite must be 4 characters long!");
			}
		}
		
		if (fr > 0)
		{
			psp.Frame = fr;
		}
		return;
	}
	
	//--------------------------------------------------------------------------
	action bool AkOverlay(int layer, statelabel start = null, bool nooverride = false, int id = 0)
	{
		if (!id) id = OverlayID();
		
		bool ret = A_Overlay(layer, start, nooverride);
		if (!ret)	return false;
		
		if (id < 0)
		{
			A_OverlayFlags(layer,PSPF_FLIP|PSPF_ADDWEAPON|PSPF_MIRROR,true);
		}
		let plr = invoker.owner.player;
		if (!plr) return ret;
		
		let psr = plr.FindPSprite(id);
		let psp = plr.FindPSprite(layer);
		if (!psp || !psr)	return ret;
		
		psp.oldx = psp.x = psr.x;
		psp.oldy = psp.y = psr.y;
		return ret;
	}
	
	//--------------------------------------------------------------------------
	// Offsets the overlays based upon which side is doing it, allowing for
	// easy mirroring without getting into heavy intrinsic bullshit.
	action void AkOffset(Vector2 offs = (0.0, 0.0), int flags = 0, bool update = false, int id = 0, int newtic = -1)
	{
		if (!id) id = OverlayID();
		if (id == OV_LeftWeapon)
		{
			if (flags & WOF_KEEPX) offs.x = invoker.LO.x;
			if (flags & WOF_KEEPY) offs.y = invoker.LO.y;
			// Inverse the X coordinates here so it acts like mirroring. Saves a fuckton of time.
			//invoker.LO = (flags & WOF_ADD) ? (invoker.LO + (-offs.x, offs.y)) : (-offs.x, offs.y);
			invoker.LO = (flags & WOF_ADD) ? (invoker.LO + offs) : offs;
			
			if (update)
			{
				invoker.LOff = (invoker.WeapOffset[(invoker.WeaponID[Left] * 2)] + LOfx, 
								invoker.WeapOffset[(invoker.WeaponID[Left] * 2) + 1] + LOfy) + invoker.LO;
				invoker.owner.A_OverlayOffset(OV_LeftWeapon, Invoker.LOff.x, Invoker.LOff.y, 
					((flags & WOF_INTERPOLATE) ? WOF_INTERPOLATE : 0));
			}
		}
		else if (id == OV_RightWeapon)
		{
			if (flags & WOF_KEEPX) offs.x = invoker.RO.x;
			if (flags & WOF_KEEPY) offs.y = invoker.RO.y;
			invoker.RO = (flags & WOF_ADD) ? (invoker.RO + offs) : offs;
			
			if (update)
			{
				invoker.ROff = (invoker.WeapOffset[(invoker.WeaponID[Right] * 2)] + ROfx, 
								invoker.WeapOffset[(invoker.WeaponID[Right] * 2) + 1] + ROfy) + invoker.RO;
				invoker.owner.A_OverlayOffset(OV_RightWeapon, Invoker.ROff.x, Invoker.ROff.y, 
					((flags & WOF_INTERPOLATE) ? WOF_INTERPOLATE : 0));
			}
		}
		else { Console.printf("%d", id); return; }
		
		if (newtic > -1)
		{
			if (CountInv("PowerD4Haste"))
			{
				let plr = invoker.owner.player;
				if (!plr) return;
				
				let psp = plr.FindPSprite(id);
				if (psp)	psp.Tics = newtic;
				
			}
		}
	}
	
	// Basically a copy of the above function.
	action void AkOffsetD(double offsx = 0.0, double offsy = 0.0, int flags = 0, bool update = false, int id = 0, int newtic = -1)
	{
		if (!id) id = OverlayID();
		if (id < 0)
		{
			// Inverse the X coordinates here so it acts like mirroring. Saves a fuckton of time.
			//invoker.LO = (flags & WOF_ADD) ? (invoker.LO + (-offsx, offsy)) : (-offsx, offsy);
			//offsx = -offsx;
			if (!(flags & WOF_KEEPX)) invoker.LO.X = (flags & WOF_ADD) ? (invoker.LO.X + offsx) : offsx;
			if (!(flags & WOF_KEEPY)) invoker.LO.Y = (flags & WOF_ADD) ? (invoker.LO.Y + offsy) : offsy;
			
			
			if (update)
			{
				if (invoker.ForceAbsCoords[Left])
				{
					invoker.LOff = (invoker.LO.X + LOfx, invoker.LO.Y + LOfy);
				}
				else
				{
					invoker.LOff = (invoker.WeapOffset[(invoker.WeaponID[Left] * 2)] + LOfx, 
									invoker.WeapOffset[(invoker.WeaponID[Left] * 2) + 1] + LOfy) + invoker.LO;
					invoker.owner.A_OverlayOffset(OV_LeftWeapon, Invoker.LOff.x, Invoker.LOff.y, 
						((flags & (WOF_ADD|WOF_INTERPOLATE)) ? WOF_INTERPOLATE : 0));
				}
			}
		}
		else if (id > 0)
		{
			if (!(flags & WOF_KEEPX)) invoker.RO.X = (flags & WOF_ADD) ? (invoker.RO.X + offsx) : offsx;
			if (!(flags & WOF_KEEPY)) invoker.RO.Y = (flags & WOF_ADD) ? (invoker.RO.Y + offsy) : offsy;
			
			if (update)
			{
				if (invoker.ForceAbsCoords[Right])
				{
					invoker.ROff = (invoker.RO.X + ROfx, invoker.RO.Y + ROfy);
				}
				else
				{
					invoker.ROff = (invoker.WeapOffset[(invoker.WeaponID[Right] * 2)] + ROfx, 
									invoker.WeapOffset[(invoker.WeaponID[Right] * 2) + 1] + ROfy) + invoker.RO;
					invoker.owner.A_OverlayOffset(OV_RightWeapon, Invoker.ROff.x, Invoker.ROff.y, 
						((flags & (WOF_ADD|WOF_INTERPOLATE)) ? WOF_INTERPOLATE : 0));
				}
			}
		}
		else { Console.printf("%d", id); return; }
		
		if (newtic > -1)
		{
			if (CountInv("PowerD4Haste"))
			{
				let plr = invoker.owner.player;
				if (!plr) return;
				
				let psp = plr.FindPSprite(id);
				if (psp)	psp.Tics = newtic;
			}
		}
	}
	
	//--------------------------------------------------------------------------
	// Similar to A_Refire but can take alts too.
	action void AkRefire(StateLabel Next, bool alt = false, bool refire = true, int id = 0)
	{
		if (!Next) 		return;
		if (!id) id = OverlayID();
		
		let player = invoker.owner.player;
		
		if (!player || !player.ReadyWeapon || !player.ReadyWeapon.FindState(Next)) 	
			return;
		
		if (id == OV_LeftWeapon)
		{
			if ((invoker.InputCur & (alt ? ALeft : PLeft)) && (refire || !(invoker.InputOld & (alt ? ALeft : PLeft))))
				player.SetPSprite(id, player.ReadyWeapon.FindState(Next));
		}
		else if (id == OV_RightWeapon)
		{
			if ((invoker.InputCur & (alt ? ARight : PRight)) && (refire || !(invoker.InputOld & (alt ? ARight : PRight))))
				player.SetPSprite(id, player.ReadyWeapon.FindState(Next));
		}
		
		return;
	}
	
	//--------------------------------------------------------------------------
	// Checks for fire buttons being pressed, with an option to allow refire.
	// alt - Check the secondary fire (A[side]) instead of the primary (P[side]).
	action bool AkCheckFire(bool alt = false, bool refire = true, int id = 0)
	{
		if (!id)	id = (OverlayID() > 0) ? OV_RightWeapon : OV_LeftWeapon;
		if (id == OV_LeftWeapon)
		{
			return (invoker.InputCur & (alt ? ALeft : PLeft)) && (refire || !(invoker.InputOld & (alt ? ALeft : PLeft)));
		}
		else if (id == OV_RightWeapon)
		{
			return (invoker.InputCur & (alt ? ARight : PRight)) && (refire || !(invoker.InputOld & (alt ? ARight : PRight)));
		}
		return false;
	}
	
	//--------------------------------------------------------------------------
	// Returns the current PSprite.
	action PSprite AkFindPSprite(int id = 0)
	{
		if (!id)	id = OverlayID();
		let plr = invoker.owner.player;
		if (plr)
		{
			let psp = plr.FindPSprite(id);
			return psp;
		}
		return null;
	}
	
	
	//==========================================================================
	// Determines which side to orient things like projectile spawning.
	// Usage is like such:
	// 		A_FireProjectile("Rocket",0,0,Side(7));
	//--------------------------------------------------------------------------
	// However, it's MUCH better to save on function calls by introducing a 
	// simple variable inside of anonymous functions if needed more than once.
	// This will drastically improve performance due to the way GZDoom handles
	// VM calls. The fewer, the better. Accessing a variable is much less
	// costly. For example:
	//
	// 	int s = Side();
	// 	for (int i = 0; i < 3; i++)
	// 		A_FireProjectile("BulletTracerFX",0,0,7*s);
	//==========================================================================
	action double Side(double val = 1.0)
	{
		int id = OverlayID();
		return val * ((id <= 0) ? -1 : 1);
	}
	//--------------------------------------------------------------------------
	// AKWeaponReady
	
	// Translations are as follows:
	// Primary - Fire Left
	// Secondary - Fire Right
	// Reload - AltFire Left
	// User1 - AltFire Right
	//--------------------------------------------------------------------------
	
	action void AkWeaponReady(int flags = 0, bool AdjustReady = false, int id = 0)
	{
		if (!id) id = OverlayID();
		let player = invoker.owner.player;
		if (!player || !player.ReadyWeapon)
		{
			//Console.Printf("ERROR -4");
			return;// ResolveState(null);
		}
		if (id != OV_LeftWeapon && id != OV_RightWeapon)
		{
			//Console.Printf("ERROR -5");
			return;// ResolveState(null);
		}
		
		bool DoFire[2], DoAltFire[2];
		let psp = player.FindPSprite(id);
		
		if (!psp) return;

		//----------------------------------------------------------------------
		// Weapon Switch Checks
		//----------------------------------------------------------------------
		// Disable switching will eliminate the pending weapon to switch to.
		if (flags & WRF_DISABLESWITCH)
		{
			if (id == OV_LeftWeapon)
			{
				invoker.SwitchMod[Left] = false;
				invoker.LeftNext = null;
				invoker.LeftPend = null;
			}
			else
			{
				invoker.SwitchMod[Right] = false;
				invoker.RightNext = null;
				invoker.RightPend = null;
			}
		}
		else if (!(flags & (WRF_NOSWITCH)) && (invoker.LeftPend || invoker.RightPend))
		{
			if (id == OV_LeftWeapon && invoker.LeftPend)
			{
				invoker.SwitchMod[Left] = false;
				invoker.Status[Left] = ChangeWeapon;
				if (psp)	{ psp.SetState(player.ReadyWeapon.FindState(invoker.LeftStates.DeselectState, true));	}
				return;
			}
			if (id == OV_RightWeapon && invoker.RightPend)
			{
				invoker.SwitchMod[Right] = false;
				invoker.Status[Right] = ChangeWeapon;
				if (psp)	{ psp.SetState(player.ReadyWeapon.FindState(invoker.RightStates.DeselectState, true));	}
				return;
			}
		}
		
		//======================================================================
		// Check for mod switching if available.
		// Cycle through the list of weapons that have mods.
		if (invoker.SwitchMod[Left] || invoker.SwitchMod[Right])
		{
			static const Class<Weapon> List[] =
			{
				"D4Shotgun",
				"D4AssaultRifle",
				"D4Chaingun",
				"D4RocketLauncher",
				"D4PlasmaRifle",
				"D4GaussCannon"
			};
			for (int i = 0; i < List.Size(); i++)
			{
				if (id == OV_LeftWeapon && invoker.SwitchMod[Left] && (invoker.LeftGun == List[i]) && (invoker.Status[Left] <= Ready))
				{
					State check = player.ReadyWeapon.FindState(invoker.LeftStates.ModState, true);
					if (check)
					{
						invoker.Status[Left] = ChangeMod;
						player.SetPSprite(id, check);
						return;
					}
				}
				
				if (id == OV_RightWeapon && invoker.SwitchMod[Right] && (invoker.RightGun == List[i]) && (invoker.Status[Right] <= Ready))
				{
					State check = player.ReadyWeapon.FindState(invoker.RightStates.ModState, true);
					if (check)
					{
						invoker.Status[Right] = ChangeMod;
						player.SetPSprite(id, check);
						return;
					}
				}
			}
		}
		
		//----------------------------------------------------------------------
		// Fire States
		//
		// Determines whether the weapon should be set to firing or not.
		// See AlWeaponReady's description for translations.
		//----------------------------------------------------------------------
		
		int input = invoker.InputCur;
		int inold = invoker.InputOld;
		
		DoFire[Left] = (!(flags & WRF_NOPRIMARY)) && (input & PLeft) && !(player.ReadyWeapon.bNOAUTOFIRE && (inold & PLeft));
		DoAltFire[Left] = (!(flags & WRF_NOSECONDARY)) && (input & ALeft) && !(player.ReadyWeapon.bNOAUTOFIRE && (inold & ALeft));
		DoFire[Right] = (!(flags & WRF_NOPRIMARY)) && (input & PRight) && !(player.ReadyWeapon.bNOAUTOFIRE && (inold & PRight));
		DoAltFire[Right] = (!(flags & WRF_NOSECONDARY)) && (input & ARight) && !(player.ReadyWeapon.bNOAUTOFIRE && (inold & ARight));

		if (DoFire[Left] || DoFire[Right])
		{
			StateLabel side = (id == OV_LeftWeapon) ? invoker.LeftStates.FireState : invoker.RightStates.FireState;
			State s = player.ReadyWeapon.FindState(side, true);
			if (id == OV_LeftWeapon && DoFire[Left] && s)
			{
				invoker.Status[Left] = Fire;
				player.SetPSprite(id, s);
				return;
					
			}
			else if (id == OV_RightWeapon && DoFire[Right] && s)
			{
				invoker.Status[Right] = Fire;
				player.SetPSprite(id, s);
				return;
			}
		}
		else if (DoAltFire[Left] || DoAltFire[Right])
		{
			StateLabel side = (id == OV_LeftWeapon) ? invoker.LeftStates.AltFireState : invoker.RightStates.AltFireState;
			State s = player.ReadyWeapon.FindState(side, true);
			if (id == OV_LeftWeapon && DoAltFire[Left] && s)
			{
				invoker.Status[Left] = AltFire;
				player.SetPSprite(id, s);
				return;	
			}
			else if (id == OV_RightWeapon && DoAltFire[Right] && s)
			{
				invoker.Status[Right] = AltFire;
				player.SetPSprite(id, s);
				return;
			}
			/*
			if (id == OV_LeftWeapon && DoAltFire[Left])
			{
				invoker.Status[Left] = AltFire;
				player.SetPSprite(id, player.ReadyWeapon.FindState(invoker.LeftStates.AltFireState, true));
			}
			if (id == OV_RightWeapon && DoAltFire[Right])
			{
				invoker.Status[Right] = AltFire;
				player.SetPSprite(id, player.ReadyWeapon.FindState(invoker.RightStates.AltFireState, true));
			}
			*/
		}
		else
		{		
			if (psp)
				psp.bAddBob = (!(flags & WRF_NOBOB));
			
			if (AdjustReady)
			{
				if (id == OV_LeftWeapon)
				{	invoker.Status[Left] = Ready;	invoker.LO = (0,0);	}
				if (id == OV_RightWeapon)						
				{	invoker.Status[Right] = Ready;	invoker.RO = (0,0);	}
			}
		}
		return;
	}
	
	//==========================================================================
	// CheckMods
	//
	// Performs special checks for special weapons first before mod checking.
	// If it's not a special weapon, indicate it by setting the variable and
	// letting AkWeaponReady do the rest.
	//==========================================================================
	
	action bool CheckMods(int side, bool checkonly = false)
	{
		// Pistol: 			Toggle lance mode
		// Repeater: 		Toggle single fire mode
		// Carrion Cannon: 	Absorb corpses
		// BFG: 			Redirect shots
		static const Class<Inventory> Spec[] =
		{
			"D4Pistol",
			"D4Repeater",
			"D4LightningGun",
			"D4CarrionCannon",
			"D4BFG"
		};
		side = Clamp(side, Left, Right);
		Class<Inventory> Gun = (side) ? invoker.RightGun : invoker.LeftGun;
		
		if (invoker.Status[side] != Ready)	return false;
		
		// Pistol: Toggles lance mode.
		if (Gun == "D4Pistol")
		{
			if (CountInv("PistolUpgradeLance"))
			{
				if (checkonly) return true;
				if (CountInv("PistolLanceActive"))	A_SetInventory("PistolLanceActive",0);
				else
				{
				//	A_PlaySound("Doom4/Weapon/GaussGun/PrecisionDown",CHAN_WEAPON,1);	
					A_SetInventory("PistolLanceActive",1);
				}
				return true;
			}
			return false;
		}
		// Repeater: Switches between three and one shot.
		else if (Gun == "D4Repeater")
		{
			if (checkonly) return true;
			ACS_NamedExecute("ToggleRepeaterMode",0,0,0,0);
			return true;
		}
		// Lightning gun: Toggles chain firing.
		else if (Gun == "D4LightningGun")
		{
			if (CountInv("LGUpgradeAltFire"))
			{
				if (checkonly)	return true;
				if (CountInv("LGChainToggle"))	A_SetInventory("LGChainToggle",0);
				else
				{
				//	A_PlaySound("Doom4/Weapon/GaussGun/PrecisionDown",CHAN_WEAPON,1);	
					A_SetInventory("LGChainToggle",1);
				}
				return true;				
			}
			return false;
		}
		// Carrion Cannon: Triggers absorption.
		else if (Gun == "D4CarrionCannon")
		{
			if (checkonly) return true;
			let plr = invoker.owner.player;
			if (plr)
			{
				let psp = plr.FindPSprite(OverlayID());
				State s = FindState("D4CarrionCannon.Mod", true);
				if (psp && s)
				{
					int oid = (side) ? OV_RightWeapon : OV_LeftWeapon;
					plr.SetPSprite(oid, s);
					return true;
				}
			}
			return false;
		}
		// BFG: Redirects projectiles.
		else if (Gun == "D4BFG")
		{
			if (CountInv("BFGUpgrade4"))
			{
				if (checkonly) return true;
				A_FireBullets(0,0,1,0,"BFGRedirectPuff",FBF_NORANDOMPUFFZ|FBF_NOFLASH,32766);
				A_GiveToChildren("BFGRedirector",1);
				return true;
			}
			return false;			
		}
		
		// Otherwise, indicates the mod wishes to be changed. This is handled
		// elsewhere to ensure things are not messed with.
		invoker.SwitchMod[side] = true;
		return true;
	}
	
	//==========================================================================
	// ChangeMods
	// 
	// Returns the following sprite names for use with the function, based on
	// if a mod switch is okay or not.
	//
	// If check only, do not actually perform a switch. Simply return a special
	// name to indicate like a boolean.
	//
	// Returns are:
	// NOPE: Mod change failed.
	// ----: ^ + Maintain the same sprite.
	// OKAY: Mod change is ready.
	//==========================================================================
	
	action Name ChangeMods(bool checkonly = false, int id = 0)
	{
		
		if (!id) id = OverlayID();
		int side = (id < 0) ? Left : Right;
		
		if ((id != OV_LeftWeapon && id != OV_RightWeapon))	
		{
			invoker.SwitchMod[side] = false;
			return 'NOPE';
		}
		
	
		static const Class<Inventory> WeaponModdableList[] =
		{
			"D4Shotgun",
			"D4AssaultRifle",
			"D4Chaingun",
			"D4RocketLauncher",
			"D4PlasmaRifle",
			"D4GaussCannon"
		};
		// Mods are aligned with active for easier tracking.
		// This is the list of available mods, complimented with the next array
		// which specifies which mod is active. Only one can be at any time.
		static const Class<Inventory> ModList[] =
		{
			"ShotgunMod1",			"ShotgunMod2",
			"AssaultRifleMod1", 	"AssaultRifleMod2",
			"ChaingunMod1",			"ChaingunMod2",			
			"RocketLauncherMod1", 	"RocketLauncherMod2", 	
			"PlasmaRifleMod1",		"PlasmaRifleMod2", 		
			"GaussCannonMod1",		"GaussCannonMod2" 		
		};
		
		static const Class<Inventory> ActiveList[] =
		{
			"TriShotActive",		"GrenadeActive",
			"TacticalScopeActive",	"MicroMissilesActive",
			"GatlingRotatorActive", "MobileTurretActive",
			"DetonateActive",		"LockOnActive",
			"HeatBlastActive",		"StunBombActive",
			"PrecisionActive",		"SiegeActive"
		};
		static const Sound SoundList[] =
		{
			"Doom4/Weapon/Shotgun/SwitchToTripleShot",		"Doom4/Weapon/Shotgun/SwitchToGrenade",
			"Doom4/Weapon/Machinegun/SwitchToScope",		"Doom4/Weapon/Machinegun/SwitchToMissiles",
			"Doom4/Weapon/Chaingun/SwitchToRotator",		"Doom4/Weapon/Chaingun/SwitchToTurret",
			"Doom4/Weapon/RocketLauncher/SwitchToDetonate",	"Doom4/Weapon/RocketLauncher/SwitchToLock",
			"Doom4/Weapon/PlasmaGun/SwitchToHeat",			"Doom4/Weapon/PlasmaGun/SwitchToElectro",
			"Doom4/Weapon/GaussGun/SwitchToPrecision",		"Doom4/Weapon/GaussGun/SwitchToSiege"
		};
		static const Name SpriteList[] =
		{
			'DW3F', 'DW3B',
			'ARSI', 'ARMI',
			'CGRS', 'CT2S',
			'RLDI', 'RLLI',
			'PRHI', 'PRSI',
			'GCPI', 'GCSI'
		};
		
		Class<Inventory> Mod1, Mod2, ActiveMod1, ActiveMod2;
		Name Spr1, Spr2;
		Sound snd;
		bool FoundGun = false;
		
		let io = invoker.owner;
		for (int i = 0; i < WeaponModdableList.Size(); i++)
		{
			int PIndex = i * 2;
			int SIndex = (i * 2) + 1;
			if ((id == OV_LeftWeapon && invoker.SwitchMod[Left] && invoker.LeftGun == WeaponModdableList[i]) ||
				(id == OV_RightWeapon && invoker.SwitchMod[Right] && invoker.RightGun == WeaponModdableList[i]))
			{
				Mod1 = ModList[PIndex];
				Mod2 = ModList[SIndex];
				ActiveMod1 = ActiveList[PIndex];
				ActiveMod2 = ActiveList[SIndex];
				Spr1 = SpriteList[PIndex];
				Spr2 = SpriteList[SIndex];
				
				if (io.CountInv(ActiveMod1))	snd = SoundList[SIndex];
				else							snd = SoundList[PIndex];
				/*
				if (checkonly)
				{
					int deb[4];
					deb[0] = io.CountInv(Mod1);
					deb[1] = io.CountInv(Mod2);
					deb[2] = io.CountInv(ActiveMod1);
					deb[3] = io.CountInv(ActiveMod2);
					Console.Printf("%s - %d\n%s - %d\n%s - %d\n%s - %d", 
						Mod1.GetClassName(), deb[0],
						Mod2.GetClassName(), deb[1],
						ActiveMod1.GetClassName(), deb[2],
						ActiveMod2.GetClassName(), deb[3]);
				}
				*/
				FoundGun = true;
				break;
			}
		}
		
		if (!checkonly) invoker.SwitchMod[side] = false;
		if (!FoundGun) 
		{
			invoker.SwitchMod[side] = false;
			//Console.Printf("Gun not found");
			return (checkonly ? 'NOPE' : '----');
		}
		
		
		if (io.CountInv(Mod1) && io.CountInv(Mod2))
		{
			if (checkonly) return 'OKAY';
			if (io.CountInv(ActiveMod1))
			{
				io.A_SetInventory(ActiveMod1,0);
				io.A_SetInventory(ActiveMod2,1);
				return spr2;
				
			}
			else
			{
				if (checkonly) return 'OKAY';
				io.A_SetInventory(ActiveMod1,1);
				io.A_SetInventory(ActiveMod2,0);
				return spr1;
			}
		}
		else if (io.CountInv(Mod1) && (!io.CountInv(ActiveMod1) || io.CountInv(ActiveMod2))) //if has TacticalScope (Mod1)
		{
			if (checkonly) return 'OKAY';
			A_SetInventory(ActiveMod1,1);
			A_SetInventory(ActiveMod2,0);
			return spr1;
		}
		else if (io.CountInv(Mod2) && (!io.CountInv(ActiveMod2) || io.CountInv(ActiveMod1))) //if it has MicroMissiles
		{
			if (checkonly) return 'OKAY';
			io.A_SetInventory(ActiveMod1,0);
			io.A_SetInventory(ActiveMod2,1);
			return spr2;
		}
		else
		{
			ACS_NamedExecute("NoModsAvailable",0,0,0,0);
		}
		invoker.SwitchMod[side] = false;
		return (checkonly ? 'NOPE' : '----');
	}
	
	//--------------------------------------------------------------------------
	//
	// AkRaiseGun
	//
	//--------------------------------------------------------------------------
	action void AkRaiseGun(int RaiseSpeed = 6, bool instaraise = false)
	{
		int id = OverlayID();
		let player = invoker.owner.player;
		if (!player || !player.ReadyWeapon || (id != OV_LeftWeapon && id != OV_RightWeapon))
			return;
		
		let psp = player.FindPSprite(id);
		if (psp)
		{
			psp.oldy = psp.y;
			AkOffset((0,-RaiseSpeed),WOF_ADD);
			double CurrentY = (id == OV_LeftWeapon) ? invoker.LO.y : invoker.RO.y;
			if (CurrentY <= 0 || instaraise)
			{
				AkOffset(); psp.oldy = psp.y;
				psp.SetState(player.ReadyWeapon.FindState((id == OV_RightWeapon) ? invoker.RightStates.ReadyState : invoker.LeftStates.ReadyState, true));
				invoker.Status[(id == OV_RightWeapon ? Right : Left)] = Ready;
				return;
			}
		}
		return;
	}
	
	//--------------------------------------------------------------------------
	//
	// AkLowerGun
	//
	//--------------------------------------------------------------------------
	action void AkLowerGun(int LowerSpeed = 6, bool instalower = false)
	{
		int id = OverlayID();
		let player = invoker.owner.player;
		if (!player || !player.ReadyWeapon || invoker.IsLowering || (id != OV_LeftWeapon && id != OV_RightWeapon))
			return;
		
		let psp = player.FindPSprite(id);
		if (psp)
		{
			invoker.Status[(id == OV_RightWeapon ? Right : Left)] = ChangeWeapon;
			//psp.oldy = psp.y;
			//psp.y += LowerSpeed;
			AkOffset((0,LowerSpeed),WOF_ADD|WOF_INTERPOLATE,true);
			double CurrentY = (id == OV_LeftWeapon) ? invoker.LO.y : invoker.RO.y;
			if (CurrentY >= WEAPONBOTTOM || instalower)
			{
				//psp.y = psp.oldy = WEAPONBOTTOM;
				AkOffset((0,WEAPONBOTTOM),WOF_INTERPOLATE,true);
				psp.SetState(player.ReadyWeapon.FindState((id == OV_RightWeapon) ? invoker.RightNext : invoker.LeftNext, true));
				if (id == OV_RightWeapon)
				{
					invoker.ForceAbsCoords[Right] = false;
					invoker.RightGun = invoker.RightPend;
					invoker.RightPend = null;
					invoker.RightNext = null;
					for (int i = 0; i < 8; i++)
						invoker.SoundMaker[Left].A_StopSound(i);
				}
				else
				{
					invoker.ForceAbsCoords[Left] = false;
					invoker.LeftGun = invoker.LeftPend;
					invoker.LeftPend = null;
					invoker.LeftNext = null;
					for (int i = 0; i < 8; i++)
						invoker.SoundMaker[Right].A_StopSound(i);
				}
				return;
			}
		}
		
		return;
	}
	
	// When Graf makes string to state labels a thing, I can dump this shit.
	action void PrepareStates()
	{
		invoker.as[ID_D4Pistol].ReadyState = 			"D4Pistol.Ready";
		invoker.as[ID_D4Pistol].FireState = 			"D4Pistol.Fire";
		invoker.as[ID_D4Pistol].AltFireState = 			"D4Pistol.AltFire";
		invoker.as[ID_D4Pistol].SelectState = 			"D4Pistol.Select";
		invoker.as[ID_D4Pistol].DeselectState = 		"D4Pistol.Deselect";
		invoker.as[ID_D4Pistol].ModState = 				"D4Pistol.Mod";
		
		invoker.as[ID_D4Shotgun].ReadyState = 			"D4Shotgun.Ready";
		invoker.as[ID_D4Shotgun].FireState = 			"D4Shotgun.Fire";
		invoker.as[ID_D4Shotgun].AltFireState = 		"D4Shotgun.AltFire";
		invoker.as[ID_D4Shotgun].SelectState = 			"D4Shotgun.Select";
		invoker.as[ID_D4Shotgun].DeselectState = 		"D4Shotgun.Deselect";
		invoker.as[ID_D4Shotgun].ModState = 			"D4Shotgun.Mod";
		
		invoker.as[ID_D4SuperShotgun].ReadyState = 		"D4SuperShotgun.Ready";
		invoker.as[ID_D4SuperShotgun].FireState = 		"D4SuperShotgun.Fire";
		invoker.as[ID_D4SuperShotgun].AltFireState = 	"D4SuperShotgun.AltFire";
		invoker.as[ID_D4SuperShotgun].SelectState = 	"D4SuperShotgun.Select";
		invoker.as[ID_D4SuperShotgun].DeselectState = 	"D4SuperShotgun.Deselect";
		invoker.as[ID_D4SuperShotgun].ModState = 		"D4SuperShotgun.Mod";
		
		invoker.as[ID_D4Repeater].ReadyState = 			"D4Repeater.Ready";
		invoker.as[ID_D4Repeater].FireState = 			"D4Repeater.Fire";
		invoker.as[ID_D4Repeater].AltFireState = 		"D4Repeater.AltFire";
		invoker.as[ID_D4Repeater].SelectState = 		"D4Repeater.Select";
		invoker.as[ID_D4Repeater].DeselectState = 		"D4Repeater.Deselect";
		invoker.as[ID_D4Repeater].ModState = 			"D4Repeater.Mod";
		
		invoker.as[ID_D4AssaultRifle].ReadyState = 		"D4AssaultRifle.Ready";
		invoker.as[ID_D4AssaultRifle].FireState = 		"D4AssaultRifle.Fire";
		invoker.as[ID_D4AssaultRifle].AltFireState = 	"D4AssaultRifle.AltFire";
		invoker.as[ID_D4AssaultRifle].SelectState = 	"D4AssaultRifle.Select";
		invoker.as[ID_D4AssaultRifle].DeselectState = 	"D4AssaultRifle.Deselect";
		invoker.as[ID_D4AssaultRifle].ModState = 		"D4AssaultRifle.Mod";
		
		invoker.as[ID_D4Chaingun].ReadyState = 			"D4Chaingun.Ready";
		invoker.as[ID_D4Chaingun].FireState = 			"D4Chaingun.Fire";
		invoker.as[ID_D4Chaingun].AltFireState = 		"D4Chaingun.AltFire";
		invoker.as[ID_D4Chaingun].SelectState = 		"D4Chaingun.Select";
		invoker.as[ID_D4Chaingun].DeselectState = 		"D4Chaingun.Deselect";
		invoker.as[ID_D4Chaingun].ModState = 			"D4Chaingun.Mod";
		
		invoker.as[ID_D4RocketLauncher].ReadyState = 	"D4RocketLauncher.Ready";
		invoker.as[ID_D4RocketLauncher].FireState = 	"D4RocketLauncher.Fire";
		invoker.as[ID_D4RocketLauncher].AltFireState = 	"D4RocketLauncher.AltFire";
		invoker.as[ID_D4RocketLauncher].SelectState = 	"D4RocketLauncher.Select";
		invoker.as[ID_D4RocketLauncher].DeselectState = "D4RocketLauncher.Deselect";
		invoker.as[ID_D4RocketLauncher].ModState = 		"D4RocketLauncher.Mod";
		
		invoker.as[ID_D4PlasmaRifle].ReadyState = 		"D4PlasmaRifle.Ready";
		invoker.as[ID_D4PlasmaRifle].FireState = 		"D4PlasmaRifle.Fire";
		invoker.as[ID_D4PlasmaRifle].AltFireState = 	"D4PlasmaRifle.AltFire";
		invoker.as[ID_D4PlasmaRifle].SelectState = 		"D4PlasmaRifle.Select";
		invoker.as[ID_D4PlasmaRifle].DeselectState = 	"D4PlasmaRifle.Deselect";
		invoker.as[ID_D4PlasmaRifle].ModState = 		"D4PlasmaRifle.Mod";
		
		invoker.as[ID_D4LightningGun].ReadyState = 		"D4LightningGun.Ready";
		invoker.as[ID_D4LightningGun].FireState = 		"D4LightningGun.Fire";
		invoker.as[ID_D4LightningGun].AltFireState = 	"D4LightningGun.AltFire";
		invoker.as[ID_D4LightningGun].SelectState = 	"D4LightningGun.Select";
		invoker.as[ID_D4LightningGun].DeselectState = 	"D4LightningGun.Deselect";
		invoker.as[ID_D4LightningGun].ModState = 		"D4LightningGun.Mod";
		
		invoker.as[ID_D4StaticRifle].ReadyState = 		"D4StaticRifle.Ready";
		invoker.as[ID_D4StaticRifle].FireState = 		"D4StaticRifle.Fire";
		invoker.as[ID_D4StaticRifle].AltFireState = 	"D4StaticRifle.AltFire";
		invoker.as[ID_D4StaticRifle].SelectState =		"D4StaticRifle.Select";
		invoker.as[ID_D4StaticRifle].DeselectState = 	"D4StaticRifle.Deselect";
		invoker.as[ID_D4StaticRifle].ModState = 		"D4StaticRifle.Mod";
		
		invoker.as[ID_D4VortexRifle].ReadyState = 		"D4VortexRifle.Ready";
		invoker.as[ID_D4VortexRifle].FireState = 		"D4VortexRifle.Fire";
		invoker.as[ID_D4VortexRifle].AltFireState = 	"D4VortexRifle.AltFire";
		invoker.as[ID_D4VortexRifle].SelectState = 		"D4VortexRifle.Select";
		invoker.as[ID_D4VortexRifle].DeselectState = 	"D4VortexRifle.Deselect";
		invoker.as[ID_D4VortexRifle].ModState = 		"D4VortexRifle.Mod";
		
		invoker.as[ID_D4GaussCannon].ReadyState = 		"D4GaussCannon.Ready";
		invoker.as[ID_D4GaussCannon].FireState = 		"D4GaussCannon.Fire";
		invoker.as[ID_D4GaussCannon].AltFireState = 	"D4GaussCannon.AltFire";
		invoker.as[ID_D4GaussCannon].SelectState = 		"D4GaussCannon.Select";
		invoker.as[ID_D4GaussCannon].DeselectState = 	"D4GaussCannon.Deselect";
		invoker.as[ID_D4GaussCannon].ModState = 		"D4GaussCannon.Mod";
		
		invoker.as[ID_D4CarrionCannon].ReadyState = 	"D4CarrionCannon.Ready";
		invoker.as[ID_D4CarrionCannon].FireState = 		"D4CarrionCannon.Fire";
		invoker.as[ID_D4CarrionCannon].AltFireState = 	"D4CarrionCannon.AltFire";
		invoker.as[ID_D4CarrionCannon].SelectState = 	"D4CarrionCannon.Select";
		invoker.as[ID_D4CarrionCannon].DeselectState = 	"D4CarrionCannon.Deselect";
		invoker.as[ID_D4CarrionCannon].ModState = 		"D4CarrionCannon.Mod";
		
		invoker.as[ID_D4BFG].ReadyState = 				"D4BFG.Ready";
		invoker.as[ID_D4BFG].FireState = 				"D4BFG.Fire";
		invoker.as[ID_D4BFG].AltFireState = 			"D4BFG.AltFire";
		invoker.as[ID_D4BFG].SelectState = 				"D4BFG.Select";
		invoker.as[ID_D4BFG].DeselectState = 			"D4BFG.Deselect";
		invoker.as[ID_D4BFG].ModState = 				"D4BFG.Mod";
	}
	
	action void UpdateStates(int index)
	{
		int id = OverlayID();
		index = Clamp(index, ID_D4Pistol, ID_D4BFG);
		if (id == OV_LeftWeapon)
		{
			invoker.WeaponID[Left] = index;
			invoker.owner.A_SetInventory("LeftWeaponCount",index);
			invoker.LeftStates.ReadyState =		invoker.as[index].ReadyState;
			invoker.LeftStates.FireState =		invoker.as[index].FireState;
			invoker.LeftStates.AltFireState =	invoker.as[index].AltFireState;
			invoker.LeftStates.SelectState =	invoker.as[index].SelectState;
			invoker.LeftStates.DeselectState =	invoker.as[index].DeselectState;
			invoker.LeftStates.ModState =		invoker.as[index].ModState;
		}
		else if (id == OV_RightWeapon)
		{
			invoker.WeaponID[Right] = index;
			invoker.owner.A_SetInventory("RightWeaponCount",index);
			invoker.RightStates.ReadyState =	invoker.as[index].ReadyState;
			invoker.RightStates.FireState =		invoker.as[index].FireState;
			invoker.RightStates.AltFireState =	invoker.as[index].AltFireState;
			invoker.RightStates.SelectState =	invoker.as[index].SelectState;
			invoker.RightStates.DeselectState =	invoker.as[index].DeselectState;
			invoker.RightStates.ModState =		invoker.as[index].ModState;
		}
	}

	//==========================================================================
	// Checks and switchers
	//==========================================================================
	
	
	static const Class<Weapon> WeaponList[] =
	{
		null,
		"D4Pistol",
		"D4Shotgun",
		"D4SuperShotgun",
		"D4Repeater",
		"D4AssaultRifle",
		"D4Chaingun",
		"D4RocketLauncher",
		"D4PlasmaRifle",
		"D4LightningGun",
		"D4GaussCannon",
		"D4VortexRifle",
		"D4StaticRifle",
		"D4CarrionCannon",
		"D4BFG"
	};
	
	static const StateLabel WeaponReadyStates[] =
	{
		null,
		"D4Pistol.Select",
		"D4Shotgun.Select",
		"D4SuperShotgun.Select",
		"D4Repeater.Select",
		"D4AssaultRifle.Select",
		"D4Chaingun.Select",
		"D4RocketLauncher.Select",
		"D4PlasmaRifle.Select",
		"D4LightningGun.Select",
		"D4GaussCannon.Select",
		"D4VortexRifle.Select",
		"D4StaticRifle.Select",
		"D4CarrionCannon.Select",
		"D4BFG.Select"
	};
	
	action bool AkimboCheckWeapons(bool CheckOnly = false)
	{
		bool LeftFound = true, RightFound = true;
		int WeaponCount;
		
		int a = invoker.Owner.CountInv("LeftWeaponCount");
		int b = invoker.Owner.CountInv("RightWeaponCount");
		if (a && b)
		{
			invoker.LeftPend = invoker.WeaponList[a];
			invoker.LeftNext = invoker.WeaponReadyStates[a];
			invoker.RightPend = invoker.WeaponList[b];
			invoker.RightNext = invoker.WeaponReadyStates[b];
			return true;
		}
		
		int size = invoker.WeaponList.Size();
		for (int i = 0; i < size; i++)
		{
			if (invoker.Owner.CountInv(invoker.WeaponList[i]))
				WeaponCount++;
		}
		
		// Not enough guns to switch to this.
		if (WeaponCount < 2)
			return false;
		
		if (!invoker.RightGun && !invoker.RightPend)
		{
			RightFound = false;
			for (int i = StartIndex; i < size; i++)
			{
				if (invoker.Owner.CountInv(invoker.WeaponList[i]) && 
					(invoker.LeftGun != invoker.WeaponList[i]) && 
					(invoker.LeftPend != invoker.WeaponList[i]))
				{
					RightFound = true;
					if (!CheckOnly)
					{
						invoker.WeaponID[Right] = i;
						invoker.Owner.A_SetInventory("RightWeaponCount", i);
						invoker.RightPend = invoker.WeaponList[i];
						invoker.RightNext = invoker.WeaponReadyStates[i];
						break;
					}
				}
			}
		}
		
		if (!invoker.LeftGun && !invoker.LeftPend)
		{
			LeftFound = false;
			for (int i = StartIndex; i < size; i++)
			{
				if (invoker.Owner.CountInv(invoker.WeaponList[i]) && 
					(invoker.RightGun != invoker.WeaponList[i]) && 
					(invoker.RightPend != invoker.WeaponList[i]))
				{
					LeftFound = true;
					if (!CheckOnly)
					{
						invoker.WeaponID[Left] = i;
						invoker.Owner.A_SetInventory("LeftWeaponCount", i);
						invoker.LeftPend = invoker.WeaponList[i];
						invoker.LeftNext = invoker.WeaponReadyStates[i];
						break;
					}
				}
			}
		}
		return LeftFound && RightFound;
	}
	
	//--------------------------------------------------------------------------
	// For external use outside of the weapon itself.
	bool SetWeaponSide (Name WeapID, bool right, bool forced = false)
	{
		Class<Weapon> id = WeapID;
		if (!id || !Owner.CountInv(id))
			return false;
		
		
		// Reject if the weapon is already raised in the same hand.
		if (forced)
		{
			if (right)
			{	
				if (id == RightPend || id == RightGun)
					return false; 
				
			}
			else
			{	
				if (id == LeftPend || id == LeftGun)
					return false;
			}
		}
		// Reject if in either already.	
		else if (id == RightPend || id == RightGun || id == LeftPend || id == LeftGun)
			return false;
		
		int size = WeaponList.Size();
		for (int i = 0; i < size; i++)
		{
			if (id == WeaponList[i])
			{
				
				if (right)		{	RightPend = id; RightNext = WeaponReadyStates[i]; 	}
				else			{	LeftPend = id; 	LeftNext = WeaponReadyStates[i];	}
				//Console.Printf(WeapID.." command received successfully.");
				return true;
			}
		}
		//Console.Printf("Something's wrong.");
		return false;
	}
	
	//--------------------------------------------------------------------------
	// Class edition of the above.
	
	bool SetWeaponSideClass (Class<Weapon> id, bool right, bool forced)
	{
		if (!id || 
			//LeftGun == id || LeftPend == id ||
			//RightGun == id || RightPend == id ||
			!Owner.CountInv(id))
		{
			return false;
		}
		
		// Reject if the weapon is already raised in the same hand.
		if (forced)
		{
			if (right)
			{	
				if (id == RightPend || id == RightGun)
					return false; 
				
			}
			else
			{	
				if (id == LeftPend || id == LeftGun)
					return false;
			}
		}
		// Reject if in either already.	
		else if (id == RightPend || id == RightGun || id == LeftPend || id == LeftGun)
			return false;
		
		int size = WeaponList.Size();
		for (int i = 0; i < size; i++)
		{
			if (id == WeaponList[i])
			{
				if (right)		{	RightPend = id; RightNext = WeaponReadyStates[i]; 	}
				else			{	LeftPend = id; 	LeftNext = WeaponReadyStates[i];	}
				return true;
			}
		}
		return false;
	}
	
	
	
	//==========================================================================
	// Needed for the carrion cannon.
	Array<Actor> Enemies;
	Array<Double> EnemyDistance;
	action void OpeningPortals(int count, int ammoConsume)
	{
		invoker.owner.A_SetInventory("CarrionPortalsOpened",count);
		invoker.owner.A_AlertMonsters();
		invoker.owner.A_TakeInventory("D4Carrion",ammoConsume,TIF_NOTAKEINFINITE);
	}
	
	//==========================================================================
	//==========================================================================
	// Main states
	// These had a bad habit of getting in the way of my find + replacing, so
	// this should help prevent future fuck-ups from occurring.
	//==========================================================================
	//==========================================================================
	
	States
	{
	Overlay.OffsetManager:
		TNT1 A 1
		{
			//if (invoker.SoundMaker[Left])	invoker.SoundMaker[Left].A_Warp(AAPTR_MASTER, 5, -5,
			let io = PlayerPawn(invoker.owner);
			for (int i = 0; i < 2; i++)
			{
				if (invoker.SoundMaker[i])
				{
					invoker.SoundMaker[i].SetOrigin(io.pos + (0, 0, io.ViewHeight),false);
					invoker.SoundMaker[i].vel = io.vel;
				}
			}
			//invoker.WeaponID[Left] = invoker.owner.CountInv("LeftWeaponCount");
			//invoker.WeaponID[Right] = invoker.owner.CountInv("RightWeaponCount");
			
			// Set the left weapon's offsets.
			/*
			invoker.LOff = (invoker.WeapOffset[(invoker.WeaponID[Left] * 2)] + LOfx, 
							invoker.WeapOffset[(invoker.WeaponID[Left] * 2) + 1] + LOfy) + invoker.LO;
			io.A_OverlayOffset(OV_LeftWeapon, Invoker.LOff.x, Invoker.LOff.y, 
				(invoker.interpolate[Left] ? WOF_INTERPOLATE : 0));
			//A_OverlayOffset(OV_LeftWeapon, Invoker.ROff.x, Invoker.ROff.y, WOF_INTERPOLATE);
			
			// And the right one.
			invoker.ROff = (invoker.WeapOffset[(invoker.WeaponID[Right] * 2)] + ROfx, 
							invoker.WeapOffset[(invoker.WeaponID[Right] * 2) + 1] + ROfy) + invoker.RO;
			io.A_OverlayOffset(OV_RightWeapon, Invoker.ROff.x, Invoker.ROff.y, 
				(invoker.interpolate[Right] ? WOF_INTERPOLATE : 0));
			*/
			// Left side handling.
			if (invoker.ForceAbsCoords[Left])
			{
				invoker.LOff = (invoker.LO.X + LOfx, invoker.LO.Y + LOfy);
			}
			else
			{
				invoker.LOff = (invoker.WeapOffset[(invoker.WeaponID[Left] * 2)] + LOfx, 
								invoker.WeapOffset[(invoker.WeaponID[Left] * 2) + 1] + LOfy) + invoker.LO;
			}
			io.A_OverlayOffset(OV_LeftWeapon, Invoker.LOff.x, Invoker.LOff.y, WOF_INTERPOLATE);
			
			// Right side handling.
			if (invoker.ForceAbsCoords[Right])
			{
				invoker.ROff = (invoker.RO.X + ROfx, invoker.RO.Y + ROfy);
			}
			else
			{
				invoker.ROff = (invoker.WeapOffset[(invoker.WeaponID[Right] * 2)] + ROfx, 
								invoker.WeapOffset[(invoker.WeaponID[Right] * 2) + 1] + ROfy) + invoker.RO;
			}
			io.A_OverlayOffset(OV_RightWeapon, Invoker.ROff.x, Invoker.ROff.y, WOF_INTERPOLATE);
		}
		Wait;
	//==========================================================================
	// Main States
	//==========================================================================
	Spawn:
		M666 A 0;
		Stop;
	Select:
		M666 A 1 
		{
			
			invoker.IsLowering = false;
			if (!AkimboCheckWeapons())
			{
				A_SelectWeapon("D4Pistol");
				return ResolveState("Deselect");
			}
			let isl = invoker.SoundMaker[Left];
			let isr = invoker.SoundMaker[Right];
			if (!isl)	invoker.SoundMaker[Left] = Spawn("AkimboSoundMaker",pos);
			if (!isr)	invoker.SoundMaker[Right] = Spawn("AkimboSoundMaker",pos);
			invoker.ForceAbsCoords[Left] =
			invoker.ForceAbsCoords[Right] = false;
			invoker.interpolate[Left] = 
			invoker.interpolate[Right] = true;
			invoker.PrepareStates();
			int ci = invoker.owner.CountInv("LeftWeaponCount");
			invoker.WeaponID[Left] = ci;
			invoker.LeftStates.ReadyState = 	invoker.as[ci].ReadyState;
			invoker.LeftStates.FireState = 		invoker.as[ci].FireState;
			invoker.LeftStates.AltFireState = 	invoker.as[ci].AltFireState;
			invoker.LeftStates.SelectState = 	invoker.as[ci].SelectState;
			invoker.LeftStates.DeselectState = 	invoker.as[ci].DeselectState;
			
			ci = invoker.owner.CountInv("RightWeaponCount");
			invoker.WeaponID[Right] = ci;
			invoker.RightStates.ReadyState = 		invoker.as[ci].ReadyState;
			invoker.RightStates.FireState = 		invoker.as[ci].FireState;
			invoker.RightStates.AltFireState = 		invoker.as[ci].AltFireState;
			invoker.RightStates.SelectState = 		invoker.as[ci].SelectState;
			invoker.RightStates.DeselectState = 	invoker.as[ci].DeselectState;
			
			// Skip the offsetting for this situation.
			if (!invoker.LeftGun)	invoker.LeftGun = 	invoker.LeftPend; 	invoker.LeftPend = null;
			if (!invoker.RightGun)	invoker.RightGun = 	invoker.RightPend; 	invoker.RightPend = null;
			A_Overlay(OV_LeftWeapon, 	invoker.LeftNext);
			A_Overlay(OV_RightWeapon, 	invoker.RightNext);
			A_OverlayFlags(OV_LeftWeapon, PSPF_ADDWEAPON|PSPF_FLIP|PSPF_MIRROR, true);
			A_OverlayFlags(OV_RightWeapon, PSPF_ADDWEAPON, true);
			A_Overlay(OV_Custom + 500, "Overlay.OffsetManager");
			
			// Left side handling.
			if (invoker.ForceAbsCoords[Left])
			{
				invoker.LOff = (invoker.LO.X + LOfx, invoker.LO.Y + LOfy);
			}
			else
			{
				invoker.LOff = (invoker.WeapOffset[(invoker.WeaponID[Left] * 2)] + LOfx, 
								invoker.WeapOffset[(invoker.WeaponID[Left] * 2) + 1] + LOfy) + invoker.LO;
			}
			invoker.owner.A_OverlayOffset(OV_LeftWeapon, Invoker.LOff.x, Invoker.LOff.y, WOF_INTERPOLATE);
			
			// Right side handling.
			if (invoker.ForceAbsCoords[Right])
			{
				invoker.ROff = (invoker.RO.X + ROfx, invoker.RO.Y + ROfy);
			}
			else
			{
				invoker.ROff = (invoker.WeapOffset[(invoker.WeaponID[Right] * 2)] + ROfx, 
								invoker.WeapOffset[(invoker.WeaponID[Right] * 2) + 1] + ROfy) + invoker.RO;
			}
			invoker.owner.A_OverlayOffset(OV_RightWeapon, Invoker.ROff.x, Invoker.ROff.y, WOF_INTERPOLATE);
			
			//Console.Printf("%d %d", invoker.WeaponID[Left], invoker.WeaponID[Right]);
			return ResolveState("SelLoop");
		}
	SelLoop:
		M666 A 1 A_Raise();
		M666 A 0 A_Raise(WeaponSwitchSpeed);
		Loop;
	
	// Stop all sounds and destroy the sound makers.
	Deselect:
		M666 A 0 
		{
			for (int i = 0; i < 2; i++)
			{
				if (invoker.SoundMaker[i])	
				{
					for (int j = 0; j <= 8; j++)
						invoker.SoundMaker[i].A_StopSound(j);
					invoker.SoundMaker[i].Destroy();
				}
			}
			invoker.IsLowering = true;
			invoker.LeftPend = null;
			invoker.RightPend = null;
			invoker.LeftNext = null;
			invoker.RightNext = null;
			A_OverlayFlags(OV_LeftWeapon, PSPF_ADDWEAPON, true);
			A_OverlayFlags(OV_RightWeapon, PSPF_ADDWEAPON, true);
			invoker.owner.A_SetInventory("LeftWeaponCount", invoker.WeaponID[Left]);
			invoker.owner.A_SetInventory("RightWeaponCount", invoker.WeaponID[Right]);
			A_RemoveChildren(true,RMVF_EVERYTHING,"PlasmaHeatMuzzle");
			A_ZoomFactor(1.0);
			A_SetInventory("SpinUpCount",0);
			A_SetInventory("FrameTimeLeft",0);
			A_SetInventory("AltFireToken",0);
			A_SetInventory("BusyToken",0);
			A_SetInventory("MobileTurretArmed", 0);
		}
	DesLoop:
		M666 A 1 A_Lower();
		M666 A 0 A_Lower(WeaponSwitchSpeed);
		Loop;
	Ready:
		M666 A 1 
		{	
			A_OverlayFlags(OV_LeftWeapon, PSPF_ADDWEAPON, true);
			A_OverlayFlags(OV_RightWeapon, PSPF_ADDWEAPON, true);
			for (int i = 0; i < invoker.Status.Size(); i++)
				if (invoker.Status[i] <= invoker.Nurr)
					invoker.Status[i] = Ready;
			invoker.InputCur = GetPlayerInput(MODINPUT_BUTTONS);
			invoker.InputOld = GetPlayerInput(MODINPUT_OLDBUTTONS);
			A_Overlay(OV_Custom + 500, "Overlay.OffsetManager", true);
			A_WeaponReady(WRF_NOFIRE|invoker.WeaponFlags);
			
			
			if ((invoker.InputCur & BT_USER3) && !(invoker.InputOld & BT_USER3))
			{
				Menu.SetMenu("AkimboSideSelect");
			}
			if ((invoker.InputCur & BT_USER2) && !(invoker.InputOld & BT_USER2))
			{
				if (invoker.Status[Left] <= Ready && invoker.Status[Right] <= Ready)
				{
					invoker.SetWeaponSideClass(invoker.LeftGun, true, true);
					invoker.SetWeaponSideClass(invoker.RightGun, false, true);
				}
				else
				{
					Console.Printf("Can't switch weapons while firing");
				}
			}
		}
		Loop;
	Fire:
		M666 A 1;
		Goto Ready;
	}
	
}