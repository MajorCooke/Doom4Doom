//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
// Merely the old laser code that was in D4D v2.x kept around as a reference.
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

/*==============================================================================
================================================================================
					(DEPRECATED) Trail Beams (DEPRECATED)
================================================================================
	Do not use!
	
	-----------
	Trail Types
	-----------
	
	- TrailBeam -
	Standard non-moving trail.
	
	- MovingTrailBeam -
	Interpolates with the shooter's movement and turning.
	
	- TrailBeamStaticScaling -
	Does not move. Scales in, holds, and scales out by tic settings.
	
	-----------
	Spawn Types
	-----------
	
	- TrailBeamStaticScalingSpawner -
	- TrailBeamJitterSpawner -
	

==============================================================================*/

Class MovingTrailBeam : Actor 
{
	const NoSpawn = 256;
	double dist;
	int t;
	int Zoffset;
	double UAngle;
	double UPitch;
	Vector3 pa, pb;
	double UXa, UXb;
	double UYa, UYb;
	double UZa, UZb;
	double time;
	double UScale;
	int pflags;
	int neg;
	
	Default 
	{
		+NOINTERACTION
		+FLATSPRITE
		+BRIGHT
		+ROLLCENTER
		YScale 0.25; //Don't touch this! Otherwise the trail will become broken up!
		XScale 0.03; //This modifies the width of the beam. It is safe to play around with.
		Alpha 0;
		RenderStyle "Add";
	}
	
	States
	{
	Spawn:
		X202 B 0 NoDelay
		{
			// Sets how long to split the scaling-in effect.
			time = 3.0;
			zoffset = 16;
			// Set this to the actor's same name. The TID will prevent it spawning infinitely (tid * 256).
			//A_SpawnItemEx("MovingTrailBeam",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS,tid * 256,1);
		}
		Goto Process;
	Process:
		"####" "#" 0
		{
			if (!pflags)	{ pflags = WARPF_INTERPOLATE|WARPF_NOCHECKPOSITION|WARPF_ABSOLUTEOFFSET;	}
			A_Warp(AAPTR_DEFAULT,0,0,zoffset,0,WARPF_NOCHECKPOSITION);
			// If it's a secondary trail (vertical)
			/*
			if (tid > 0)	
			{	
				Thing_ChangeTID(0,0);
				roll = pitch + 90;
				pitch = 90;
				angle += 90;
			}
			*/
			// Save our current information so we know how to properly interpolate whenever
			// the owner moves.
			neg = (Scale.X < 0) ? 1 : 0;
			UScale = Scale.X;
			UAngle = angle;
			UPitch = pitch;
			dist = GetDistance(false, AAPTR_TARGET);
			pa = pos;
			
			// Move to the shooter so we can get just how far out we are.
			A_Warp(AAPTR_TARGET,0,0,0,0,WARPF_NOCHECKPOSITION);
			pb = pa - pos;
			
			// Now move back without interpolating. Otherwise it'll look weird.
			A_Warp(AAPTR_TARGET, pb.x, pb.y, pb.z, 0, WARPF_NOCHECKPOSITION|WARPF_ABSOLUTEOFFSET);
			angle = UAngle;
			pitch = UPitch;
		}
		"####" "#" 1 
		{
			A_FadeIn(1.0,FTF_CLAMP);
			A_Warp(AAPTR_TARGET, pb.x + vel.x, pb.y + vel.y, pb.z + vel.z, 0, pflags);
			angle = UAngle;
			pitch = UPitch;
		}
		"####" "#" 1 
		{
			// Keep 'shrinking'. NEVER fade out!
			if (neg)
			{
				A_SetScale(Scale.X - (UScale / Max(1.0, time)), Scale.Y);
				if (Scale.X >= 0)	{ return ResolveState("Null"); }
			}
			else
			{
				A_SetScale(Scale.X - (UScale / Max(1.0, time)), Scale.Y);
				if (Scale.X <= 0)	{ return ResolveState("Null"); }
			}
			A_Warp(AAPTR_TARGET, pb.x + vel.x, pb.y + vel.y, pb.z + vel.z ,0, pflags);
			angle = UAngle;
			pitch = UPitch;
			return ResolveState(null);
		}
		Wait;
	}
}

Class TrailBeam : Actor 
{
	const ZOffset = 16;
	const NoSpawn = 256;
	const PFlags = WARPF_INTERPOLATE|WARPF_NOCHECKPOSITION|WARPF_COPYVELOCITY|WARPF_ABSOLUTEOFFSET;
	double time;
	double UScale;
	int neg;
	Default 
	{
		+NOINTERACTION
		+FLATSPRITE
		+BRIGHT
		+ROLLCENTER
		YScale 0.25; //Don't touch this! Otherwise the trail will become broken up!
		XScale 0.03; //This modifies the width of the beam. It is safe to play around with.
		Alpha 0;
		RenderStyle "Add";
	}
	
	States
	{
	Spawn:
		X202 B 0 NoDelay
		{
			// Sets how long to split the scaling-in effect.
			time = 3.0;
			
			// Set this to the actor's same name. The TID will prevent it spawning infinitely (tid * 256).
			//A_SpawnItemEx("TrailBeam",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS,tid * 256,1);
			return ResolveState("Process");
		}
	Process:
		"####" "#" 1
		{
			//A_Warp(AAPTR_DEFAULT,0,0,ZOffset,0,WARPF_NOCHECKPOSITION);
			UScale = Scale.X;
			neg = ((UScale < 0) ? 1 : 0);
			// If it's a secondary trail (vertical)
			/*
			if (tid > 0)	
			{	
				Thing_ChangeTID(0,0);
				roll = pitch + 90;
				pitch = 90;
				angle += 90;
			}
			*/
			A_FadeIn(1.0,FTF_CLAMP);
		}
		"####" "#" 1 
		{
			// Keep 'shrinking'. NEVER fade out!
			
			if (neg)
			{
				A_SetScale(Scale.X - (UScale / Max(1.0, time)), Scale.Y);
				if (Scale.X >= 0)	{ return ResolveState("Null"); }
			}
			else
			{			
				A_SetScale(Scale.X - (UScale / Max(1.0, time)), Scale.Y);
				if (Scale.X <= 0)	{ return ResolveState("Null"); }
			}
			return ResolveState(null);
		}
		Wait;
	}
}


//By static, I mean non-moving. Not static rifle.
Class TrailBeamStaticScaling : Actor 
{
	enum TBSS
	{
		ZOffset = 16,
		NoSpawn = 256,
		PFlags = WARPF_INTERPOLATE|WARPF_NOCHECKPOSITION|WARPF_COPYVELOCITY|WARPF_ABSOLUTEOFFSET,
	};
	double  dist;
	int t;
	double  timeup;
	double  timedown;
	double  UScale;
	int stoff;
	int neg;
	double  USin;
	int wait;
	int stage;
	
	Default 
	{
		Projectile;
		+NOINTERACTION
		+ROLLSPRITE
		+FLATSPRITE
		+ROLLCENTER
		+BRIGHT
		//RenderStyle "Add";
		XScale 0.16;
		YScale 0.248;
		Species "LaserKillable"; //So the Monster; can 'end' its attack if interrupted.
	}
	
	States
	{
	Spawn:
		"####" "#" 0 NoDelay
		{
			timeup = 10.0;
			wait = 30;	//
			timedown = 7.0;
			
			// Set this to the actor's same name. The TID will prevent it spawning infinitely (tid * 256).
			//A_SpawnItemEx("TrailBeamStaticScaling",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME,tid * 256,1);
			return ResolveState("Setup");
		}
	Setup:
		"####" "#" 0
		{
			/*
			// If it's a secondary trail (vertical)
			if (tid > 0)	
			{
				roll = pitch + 90.0;
				pitch = 90.0;
				angle += 90.0;
				Thing_ChangeTID(0,0);
			}
			*/
			UScale = Scale.X;
			Scale.X = 0;
		}
	Process:
		"####" "#" 1 
		{
			if (!stage)
			{
				USin += ((timeup >= 1.0) ? (90.0/timeup) : (90.0 / 35.0));
				A_SetScale(sin(USin) * UScale, Scale.Y);
				if (USin >= 90.0)	{	stage = 1;	}
			}
			else if (stage == 1)
			{
				USin = 90.0;
				wait--;
				if (wait <= 0)		{	stage = 2;	}
			}
			else
			{
				USin -= ((timedown >= 1.0) ? (90.0/timedown) : (90.0 / 35.0));
				A_SetScale(sin(USin) * UScale, Scale.Y);
				if (Scale.X <= 0)	{ return ResolveState("Null"); }
			}
			
			return ResolveState(null);
		}
		Wait;
	Death:
		"####" "#" 1
		{
			if (Scale.X <= 0)	{ return ResolveState("Null"); }
			USin -= ((timedown >= 1.0) ? (90.0/timedown) : (90.0 / 35.0));
			A_SetScale(sin(USin) * UScale, Scale.Y);
			return ResolveState(null);
		}
		Wait;
	}
}

//==============================================================================
//==============================================================================
// Laser Spawners
//==============================================================================
//==============================================================================

Class TrailBeamStaticScalingSpawner : Actor 
{
	enum TBSSS
	{
		SpawnFlags = SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME|SXF_TRANSFERSCALE,
	};
	const StepDistance = 31;
	const AngleRandom = 6.0; // The boundaries of angle changing (random(-AngleRandom,AngleRandom))
	const PitchRandom = 6.0; // ^ for pitch
	double UPitch;
	double UAngle;
	double dista, distb; 
	double checkfova, checkfovb;
	int checksight;
	double checkrangea, checkrangeb;
	//[0] = Current distance travelled
	//[1] = How much further to go
	int DoCheckRange;
	int DoCheckSight;
	int DoCheckFOV;
	int MaxDistance;
	int flags;
	//[0] = Current distance travelled
	//[1] = How much further to go
	Default 
	{
		Projectile;
		+NOCLIP
		+NOINTERACTION
		+NOBLOCKMAP
		RenderStyle "None";
		XScale 0.16;
		YScale 0.25;
		Species "LaserKillable";
	}
	States
	{
	Spawn:
		X202 B 0 NoDelay
		{
			MaxDistance = 30000;
			DoCheckSight = 0;
			DoCheckRange = 0;
			DoCheckFOV = 0;
			checkrangea = 4096;
			checkfova = 90.0;
			
			//Include this if one wishes to spawn a laser which co-works with this one.
			A_SpawnItemEx("TrailBeamJitterSpawner",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS);

			A_RearrangePointers(AAPTR_DEFAULT,AAPTR_TARGET,AAPTR_DEFAULT,4);
			A_FaceTracer(0,0,0,0,FAF_MIDDLE);
			// Grab the velocity IMMEDIATELY.
			if (target) { vel = target.vel; }
			
			if (MaxDistance <= 0)		{	MaxDistance = 		30000;	}
			if (checkrangea <= 0)		{	checkrangea = 		4096;	}
			if (checkfova <= 0.0)		{	checkfova =		90.0;	}
			
			// The angle and pitch won't change so go ahead and save it now.
			UPitch = pitch;
			UAngle = angle;
			distb = Min(MaxDistance, GetDistance(true,TracerPtr));
			
			// dista = distance currently travelled.
			// distb = maximum distance.
			while ((dista < distb))
			{
				if (DoCheckRange)		{	checkrangeb = (!(A_CheckRange(checkrangea,"Null",false)) ? 1 : 0);	}
				else						{	checkrangeb = 1;	}
				
				if (DoCheckSight)		{	checksight = (!(A_CheckSight("Null")) ? 1 : 0);	}
				else						{	checksight = 1;	}
				
				if (DoCheckFOV)		{	checkfovb = ((abs(GetAngle(GAF_RELATIVE|GAF_SWITCH,AAPTR_PLAYER1)) <= checkfova) ? 1 : 0);	}
				else						{	checkfovb = 1;		}
				
				// Spawn the beam with the same angle and pitch. Note that the
				// beam is being centered so we have to take that into account
				// and spawn it FORWARD based on half the beam's length.
				// Then move forward by a beam's length and repeat until done.
				if (checkrangeb && checksight && checkfovb)
				{	A_SpawnItemEx("TrailBeamStaticScaling",cos(pitch) * (StepDistance / 2.0),0,-sin(pitch) * (StepDistance / 2.0),0,0,0,0,SpawnFlags);	}
				A_Warp(AAPTR_DEFAULT,cos(pitch) * StepDistance,0,-sin(pitch) * StepDistance,0,WARPF_NOCHECKPOSITION);
				dista += StepDistance;
			}
		}
		Stop;
	}
}

Class TrailBeamJitterSpawner : Actor 
{
	const SpawnFlags = 	SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS|SXF_TRANSFERSCALE|
						SXF_TRANSFERPITCH|SXF_TRANSFERSPRITEFRAME|SXF_TRANSFERTRANSLATION;
	const Straight = 0.0001;
	const StepDistance = 31;
	int count;
	int choke;
	int chokemin;
	int chokemax;
	int checksight;
	int checkrangea, checkrangeb;
	Vector3 P;
	double UX;
	double UY;
	double UZ;
	double UPitch;
	double UAngle;
	double checkfova, checkfovb;
	double dista, distb;
	//[0] = Current distance travelled
	//[1] = How much further to go
	int InRange;
	int DoCheckRange;
	int DoCheckSight;
	int DoCheckFOV;
	int MaxDistance;
	double UAngleRandom;
	double UPitchRandom;
	Default 
	{
		Projectile;
		+NOCLIP
		+NOINTERACTION
		+NOBLOCKMAP
		RenderStyle "None";
		XScale 0.08;
		YScale 0.25;
		Species "LaserKillable";
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay
		{
			DoCheckRange = 0;			// Use Range Checker? Boolean. 
			DoCheckSight = 0;			// Use Sight Checker? Boolean. 
			DoCheckFOV = 0;			// Use Angle Checker? Boolean.
			
			count = 0; 				// How many tics this should respawn itself.
			MaxDistance = 30000;		// The absolute total length it can travel.
			
			checkrangea = 4096;		// How far in range it must be for it to spawn for a player.
			checkfova = 90.0;		// The FOV this must be in for the player.
			
			// Choke determines how often the laser should reorient itself to 
			// remain on target. The higher it goes, the more sporadic it will be.
			chokemin = 1;				// Minimum choke.
			chokemax = 7;				// Maximum choke.
			
			// Angle and pitch to randomize whenever not being choked.
			// If you want it straight, use the defined keyword Straight in these
			// parameters.
			UAngleRandom = 6.0;
			UPitchRandom = 6.0;
			return ResolveState("Setup");
		}
	Setup:
		TNT1 A 0
		{
			A_RearrangePointers(AAPTR_DEFAULT,AAPTR_TARGET,AAPTR_DEFAULT,4);
			// Grab the velocity IMMEDIATELY.
			if (target) { vel = target.vel; }
			
			// Establish defaults if unspecified.
			if (MaxDistance <= 0)		{	MaxDistance = 		30000;	}
			if (checkrangea <= 0)	{	checkrangea = 	4096;	}
			if (chokemin <= 0)			{	chokemin = 		1;		}
			if (chokemax <= 0)			{	chokemax = 		7;		}
			if (UAngleRandom <= 0.0)	{	UAngleRandom =		6.0;	}
			if (UPitchRandom <= 0.0)	{	UPitchRandom =		6.0;	}
			if (checkfova <= 0.0)	{	checkfova =		90.0;	}
			
			// The angle and pitch won't change so go ahead and save it now.
			A_FaceTracer(0,0,0,0,FAF_MIDDLE);
			UPitch = pitch;
			UAngle = angle;
			P = pos;
			distb = Min(MaxDistance, GetDistance(true,TracerPtr));
			choke = random(chokemin, chokemax);
			Scale.X *= 2.5;
			Scale.Y *= 0.485;
			return ResolveState("Sprite");
		}
	Sprite:
		TNT1 A 0 
		{
			A_SetScale(Scale.X*randompick(-1,1), Scale.Y*randompick(-1,1));
			return A_Jump(256,1,2,3,4);
		}
		X206 FGHI 0 { return ResolveState("Moving");	}
	Moving:
		"####" "#" 1
		{
			InRange = 0;
		
			// dista = distance currently travelled.
			// distb = maximum distance.
			// Make sure we always have a valid target.
			while ((dista < distb))
			{
				// Don't randomize the very first beam.
				if (dista > 0)
				{	A_FaceTracer(0,0,0,0,FAF_MIDDLE);	}
				
				// Randomizes the angle of the beams. 
				if (dista < (distb - StepDistance))
				{
					// If we're not about to reach the end, or not hitting the 
					// choker, randomize it. Otherwise, stay on target and go 
					// for the puff.
					if (choke > 0)
					{
						A_SetPitch(pitch + frandom(-UPitchRandom, UPitchRandom));
						A_SetAngle(angle + frandom(-UAngleRandom, UAngleRandom));
						choke--;
					}
					else 
					{	choke = random(chokemin, chokemax);	}
				}
				
				// Check sight, range, and FOV. If disabled, then assume the 
				// check(s) passed. For range, if the range is beyond the player
				// and it previously was, break out of the Loop; and save on 
				// processing time.
				if (DoCheckRange)		
				{	
					if (checkrangeb > 0.0)
					{	InRange = 1;	}
					
					checkrangeb = (!(A_CheckRange(checkrangea,"Null",false)) ? 1 : 0);
					
					if (!checkrangeb && InRange)
					{	break;	}
				}
				else						{	checkrangeb = 1;	}
				
				if (DoCheckSight)		{	checksight = (!(A_CheckSight("Null")) ? 1 : 0);	}
				else						{	checksight = 1;	}
				
				if (DoCheckFOV)		{	checkfovb = ((abs(GetAngle(GAF_RELATIVE|GAF_SWITCH,AAPTR_PLAYER1)) <= checkfova) ? 1.0 : 0.0);	}
				else						{	checkfovb = 1;		}
				
				// Spawn the beam with the same angle and pitch. Note that the
				// beam is being centered so we have to take that into account
				// and spawn it FORWARD based on half the beam's length.
				// Then move forward by a beam's length and repeat until done.
				if (checkrangeb && checksight && checkfovb)
				{	A_SpawnItemEx("LaserBeamJitter",cos(pitch) * (StepDistance / 2.0),0,-sin(pitch) * (StepDistance / 2.0),0,0,0,0,SpawnFlags);	}
				
				A_Warp(AAPTR_DEFAULT,cos(pitch) * StepDistance,0,-sin(pitch) * StepDistance,0,WARPF_NOCHECKPOSITION);
				dista += StepDistance;
			}
			
			count--;
			
			if (count <= 0)
			{	return ResolveState("Null");	}
			
			dista = 0.0;
			A_Warp(AAPTR_DEFAULT,P.x,P.y,P.z,UAngle,WARPF_NOCHECKPOSITION|WARPF_ABSOLUTEPOSITION|WARPF_ABSOLUTEANGLE);
			pitch = UPitch;
			return ResolveState(null);
		}
		Goto Sprite;
	Death:
		TNT1 A 0;
		Stop;
	}
}



//------------------------------------------------------------------------------
// Lightning Gun laser beams
Class LightningTrailBeamV2 : MovingTrailBeam
{
	States
	{
	Spawn:
		"####" "#" 0 NoDelay 
		{
			zoffset = 16;
			time = 4.0;
			pflags = WARPF_INTERPOLATE|WARPF_NOCHECKPOSITION|WARPF_ABSOLUTEOFFSET|WARPF_COPYVELOCITY;
			//A_SpawnItemEx("LightningTrailBeamV2",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME,tid * 256,1);
			
			return A_JumpIf(GetCvar("D4D_BeamTexture"),"Process");
		}
		X202 F 0 	{	return ResolveState("Process");	}
	}
}

Class LightningTrailBeamV3 : MovingTrailBeam
{
	Default 
	{
		Translation "0:255=%[0,0,0]:[1.25,1.0,1.85]";
	}
	States
	{
	Spawn:
		"####" "#" 0 NoDelay 
		{
			zoffset = 16;
			time = 4.0;
			pflags = WARPF_INTERPOLATE|WARPF_NOCHECKPOSITION|WARPF_ABSOLUTEOFFSET|WARPF_COPYVELOCITY;
			//A_SpawnItemEx("LightningTrailBeamV3",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME,tid * 256,1);
			
			return A_JumpIf(GetCvar("D4D_BeamTexture"),"Process");
		}
		X202 G 0 	{	Thing_SetTranslation(0,0);	return ResolveState("Process");	}
	}
}

Class LightningTrailBeamV4 : TrailBeam
{
	Default 
	{
		Translation "0:255=%[0,0,0]:[1.25,1.0,1.85]";
	}
	States
	{
	Spawn:
		"####" "#" 0 NoDelay 
		{
			time = 4.0;
			//A_SpawnItemEx("LightningTrailBeamV4",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME,tid * 256,1);
			
			return A_JumpIf(GetCvar("D4D_BeamTexture"),"Process");
		}
		X202 G 0 	{	Thing_SetTranslation(0,0);	return ResolveState("Process");	}
	}
}

Class LightningBeamV2 : Actor 
{
	enum LightningBeamV2
	{
		MaxDistance = 768,	// Maximum distance of the effect
		AngleRandom = 7,	// The boundaries of angle changing (random(-AngleRandom,AngleRandom))
		PitchRandom = 7,	// ^ for pitch
		ChokeMin = 1,		// How sooner or later the beam needs to correct itself to
		ChokeMax = 5,		// 	"stay on target".
	};
	const StepDistance = 31;
	double UPitch;
	double UAngle;
	double dista;
	double distb;
	int choke;
	int flags;
	//[0] = Current distance travelled
	//[1] = How much further to go
	Default 
	{
		+NOCLIP
		+NOINTERACTION
		+NOBLOCKMAP
		RenderStyle "None";
	}
	States
	{
	Precache:
		X206 ABCDEFGHIJKLMNOPQRSTUVWXYZ 0;
	Spawn:
		TNT1 A 0 NoDelay
		{
			// Grab the velocity IMMEDIATELY.
			if (target) { vel = target.vel; }
			
			// The angle and pitch won't change so go ahead and save it now.
			UPitch = pitch;
			UAngle = angle;
			distb = Min(MaxDistance, GetDistance(true,TracerPtr));
			choke = random(ChokeMin, ChokeMax);
			
			Scale.X = 0.03;
			Scale.Y = 0.25;
			
			Sprite = GetSpriteIndex("X206");
			Frame = random(Fr_F,Fr_I);
			
			if (GetCvar("D4D_BeamTexture"))
			{
				flags = SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERPITCH|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME;
				Scale.X *= 2.5 * randompick(-1,1);
				Scale.Y *= 0.485 * randompick(-1,1);
			}
			else
				flags = SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERPITCH|SXF_TRANSFERPOINTERS;
			return ResolveState("Moving");
		}
	Sprite:
		X206 FGHI 0 A_Jump(256,"Moving");
	Moving:
		"####" "#" 0
		{
			// dista = distance currently travelled.
			// distb = maximum distance.
			// Make sure we always have a valid target.
			while ((dista < distb))
			{
				// Don't randomize the very first beam.
				if (dista > 0)
				{	A_FaceTracer(0,0,0,0,FAF_MIDDLE);	}
				
				// Randomizes the angle of the beams. 
				if (dista < (distb - StepDistance))
				{
					// If we're not about to reach the end, or not hitting the 
					// choker, randomize it. Otherwise, stay on target and go 
					// for the puff.
					if (choke > 0)
					{
						A_SetPitch(pitch + frandom(-PitchRandom, PitchRandom));
						A_SetAngle(angle + frandom(-AngleRandom, AngleRandom));
						choke--;
					}
					else 
					{	choke = random(ChokeMin,ChokeMax);	}
				}
				// Spawn the beam with the same angle and pitch. Note that the
				// beam is being centered so we have to take that into account
				// and spawn it FORWARD based on half the beam's length.
				// Then move forward by a beam's length and repeat until done.
				A_SpawnItemEx("LightningTrailBeamV2",cos(pitch) * (StepDistance / 2.0),0,-sin(pitch) * (StepDistance / 2.0),0,0,0,0,flags);
				A_Warp(AAPTR_DEFAULT,cos(pitch) * StepDistance,0,-sin(pitch) * StepDistance,0,WARPF_NOCHECKPOSITION);
				dista += StepDistance;
			}
		}
		Stop;
	}
}

Class LightningBeamV3 : Actor 
{
	enum LightningBeamV3
	{
		MaxDistance = 768,	// Maximum distance of the effect
		AngleRandom = 7,	// The boundaries of angle changing (random(-AngleRandom,AngleRandom))
		PitchRandom = 7,	// ^ for pitch
		ChokeMin = 1,		// How sooner or later the beam needs to correct itself to
		ChokeMax = 5,		// 	"stay on target".
	};
	const StepDistance = 31;
	double UPitch;
	double UAngle;
	double dista;
	double distb;
	//[0] = Current distance travelled
	//[1] = How much further to go
	int choke;
	int t;
	int flags;
	Default 
	{
		+NOCLIP
		+NOINTERACTION
		+NOBLOCKMAP
		RenderStyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay
		{
			if (tid > 0)
			{
				t = tid;
				Thing_ChangeTID(0,0);
				
				if (A_CheckProximity("Null","LightningPuffV3",256,1,CPXF_SETTARGET))
				{
					A_TransferPointer(AAPTR_TARGET,AAPTR_DEFAULT,AAPTR_TARGET,AAPTR_MASTER);
					
					A_Warp(AAPTR_TARGET,0,0,0,0,WARPF_NOCHECKPOSITION);
					A_FaceTracer(0,0,0,0,FAF_MIDDLE);
					A_DamageTracer(countinv("LGUpgradeDamage") ? random(LGChainDmgMinUpgrade,LGChainDmgMaxUpgrade) : random(LGChainDmgMin,LGChainDmgMax),"None",0,null,"None",AAPTR_MASTER);
				}
				else
				{
					// Grab the velocity IMMEDIATELY.
					if (target) { vel = target.vel; }
				}
			}
			else
			{
				if (target) { vel = target.vel; }
			}
			
			Scale.X = 0.03;
			Scale.Y = 0.25;
			
			if (GetCvar("D4D_BeamTexture"))
			{
				flags = SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERPITCH|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME;
				Scale.X *= 2.5 * randompick(-1,1);
				Scale.Y *= 0.485 * randompick(-1,1);
				return A_Jump(256,1,2,3,4);
			}
			flags = SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERPITCH|SXF_TRANSFERPOINTERS;
			return ResolveState("Moving");
		}
	Sprite:
		X206 FGHI 0 A_Jump(256,"Moving");
	Moving:
		"####" "#" 0
		{
			// The angle and pitch won't change so go ahead and save it now.
			UPitch = pitch;
			UAngle = angle;
			distb = Min(MaxDistance, GetDistance(true,TracerPtr));
			choke = random(ChokeMin, ChokeMax);
			// dista = distance currently travelled.
			// distb = maximum distance.
			// Make sure we always have a valid target.
			while ((dista < distb))
			{
				// Don't randomize the very first beam.
				if (dista > 0)
				{	A_FaceTracer(0,0,0,0,FAF_MIDDLE);	}
				
				// Randomizes the angle of the beams. 
				if (dista < (distb - StepDistance))
				{
					// If we're not about to reach the end, or not hitting the 
					// choker, randomize it. Otherwise, stay on target and go 
					// for the puff.
					if (choke > 0)
					{
						A_SetPitch(pitch + frandom(-PitchRandom, PitchRandom));
						A_SetAngle(angle + frandom(-AngleRandom, AngleRandom));
						choke--;
					}
					else 
					{	choke = random(ChokeMin,ChokeMax);	}
				}
				// Spawn the beam with the same angle and pitch. Note that the
				// beam is being centered so we have to take that into account
				// and spawn it FORWARD based on half the beam's length.
				// Then move forward by a beam's length and repeat until done.
				//A_SpawnItemEx("LightningTrailBeamV3",cos(pitch) * (StepDistance / 2.0),0,-sin(pitch) * (StepDistance / 2.0),0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERPOINTERS);
				
				if (t)
				{	A_SpawnItemEx("LightningTrailBeamV4",cos(pitch) * (StepDistance / 2.0),0,-sin(pitch) * (StepDistance / 2.0),0,0,0,0,flags);	}
				else
				{	A_SpawnItemEx("LightningTrailBeamV3",cos(pitch) * (StepDistance / 2.0),0,-sin(pitch) * (StepDistance / 2.0),0,0,0,0,flags);	}
				
				A_Warp(AAPTR_DEFAULT,cos(pitch) * StepDistance,0,-sin(pitch) * StepDistance,0,WARPF_NOCHECKPOSITION);
				dista += StepDistance;
			}
		}
		Stop;
	}
}

Class LaserBeamJitter : TrailBeam
{
	States
	{
	Spawn:
		"####" "#" 0 NoDelay 
		{
			time = 3.0;
			//A_SpawnItemEx("LaserBeamJitter",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME|SXF_TRANSFERTRANSLATION,tid * 256,1);
			return ResolveState("Process");
		}
	}
}

Class WhiteLaserBeamJitter : TrailBeam
{
	Default 
	{
		Translation "0:255=%[0,0,0]:[1,1,1]";
	}
	States
	{
	Spawn:
		"####" "#" 0 NoDelay 
		{
			time = 3.0;
			//A_SpawnItemEx("WhiteLaserBeamJitter",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME|SXF_TRANSFERTRANSLATION,tid * 256,1);
			
			return ResolveState("Process");
		}
	}
}
//------------------------------------------------------------------------------
// Laser imp... lasers
Class WhiteLaser : TrailBeamJitterSpawner
{
	Default 
	{
		Translation "0:255=%[0,0,0]:[1,1,1]";
	}
	States
	{
	Spawn:
		"####" "#" 0 NoDelay
		{
			checkrangea = 1024;
			return ResolveState("Setup");
		}
	}
}

Class RedLaser : TrailBeamJitterSpawner
{
	Default 
	{
		Translation "0:255=%[0,0,0]:[2.0,1.0,1.0]";
		XScale 0.2;
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay
		{
			UPitchRandom = 12.0;
			UAngleRandom = 12.0;
			count = 0;
			return ResolveState("Setup");
		}
	}
}
//------------------------------------------------------------------------------
// Spider Mastermind lasers
Class BigRedLaserDrillSMM : TrailBeamStaticScalingSpawner
{
	Default 
	{
		XScale 0.2;
	}
	States
	{
	Spawn:
		X202 J 0 NoDelay
		{
			DoCheckSight = 0;
			DoCheckRange = 0;
			DoCheckFOV = 0;
			MaxDistance = 30000;
			checkrangea = 4096;
			checkfova = 90.0;
			
			A_RearrangePointers(AAPTR_DEFAULT,AAPTR_TARGET,AAPTR_DEFAULT,4);
			A_FaceTracer(0,0,0,0,FAF_MIDDLE);
			
			if (GetDistance(true,TracerPtr) <= 2048)
			{	A_SpawnItemEx("RedLaserSMM",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS);	}
			A_SpawnItemEx("RedLaserSMM",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS);
			
			// Grab the velocity IMMEDIATELY.
			if (target) { vel = target.vel; }
			
			// The angle and pitch won't change so go ahead and save it now.
			UPitch = pitch;
			UAngle = angle;
			distb = Min(MaxDistance, GetDistance(true,TracerPtr));
			
			// dista = distance currently travelled.
			// distb = maximum distance.
			while ((dista < distb))
			{
				if (DoCheckRange)		{	checkrangeb = (!(A_CheckRange(checkrangea,"Null",false)) ? 1 : 0);	}
				else						{	checkrangeb = 1;	}
				
				if (DoCheckSight)		{	checksight = (!(A_CheckSight("Null")) ? 1 : 0);	}
				else						{	checksight = 1;	}
				
				if (DoCheckFOV)		{	checkfovb = ((abs(GetAngle(GAF_RELATIVE|GAF_SWITCH,AAPTR_PLAYER1)) <= checkfova) ? 1 : 0);	}
				else						{	checkfovb = 1;		}
				
				// Spawn the beam with the same angle and pitch. Note that the
				// beam is being centered so we have to take that into account
				// and spawn it FORWARD based on half the beam's length.
				// Then move forward by a beam's length and repeat until done.
				if (checkrangeb && checksight && checkfovb)
				{	A_SpawnItemEx("BigRedLaserBeamSMM",cos(pitch) * (StepDistance / 2.0),0,-sin(pitch) * (StepDistance / 2.0),0,0,0,0,SpawnFlags);	}
				A_Warp(AAPTR_DEFAULT,cos(pitch) * StepDistance,0,-sin(pitch) * StepDistance,0,WARPF_NOCHECKPOSITION);
				dista += StepDistance;
			}
		}
		Stop;
	}
}

Class BigRedLaserBeamSMM : TrailBeamStaticScaling
{
	Default 
	{
		XScale 0.2;
	}
	States
	{
	Spawn:
		"####" "#" 0 NoDelay
		{
			timeup = 10.0;
			wait = 39;
			timedown = 7.0;
			
			// Set this to the actor's same name. The TID will prevent it spawning infinitely (tid * 256).
			// A_SpawnItemEx("BigRedLaserBeamSMM",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME,tid * 256,1);
			return ResolveState("Setup");
		}
	}
}

Class RedLaserSMM : TrailBeamJitterSpawner
{
	Default 
	{
		Translation "0:255=%[0,0,0]:[2,1,1]";
		XScale 0.2;
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay
		{
			count = 52;
			DoCheckSight = 1;
			DoCheckRange = 1;
			checkrangea = 2048;
			return ResolveState("Setup");
		}
	}
}
//------------------------------------------------------------------------------
// Static Rifle trail
Class LanceTrail : TrailBeam
{
	Default 
	{
		XScale 0.08;
	    YScale 0.12;
		Translation "0:255=%[0,0,0]:[1.0,0.2,0.2]";
	}
	States
	{
	Spawn:
		X202 B 0 NoDelay
		{
			// time = time to shrink to nothing
			//pitch *= -1;
			time = 17.0;
			A_SpawnItemEx("LanceTrail",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS,tid * 256,1);
			//if (tid) { angle += 180; }
		}
		Goto Process;
	}
}

//------------------------------------------------------------------------------
// Vortex Rifle trail
Class VortexTrail : TrailBeam
{
	Default 
	{
		XScale 0.1;
		YScale 0.25; //Don't touch.
	}
	States
	{
	Spawn:
		X202 H 0 NoDelay
		{
			//pitch *= -1;
			//if (tid) { angle += 180; }
			// time = time to shrink to nothing
			time = 15.0;
			//A_SpawnItemEx("VortexTrail",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS,tid * 256,1);
		}
		Goto Process;
	}
}

//==============================================================================
// GZDoom BFG Beam
Class BFGBeamGZ : Actor 
{
	enum BFGBeamGZ
	{
		MaxDistance = 2048,
		AngleRandom = 7,
		PitchRandom = 7,
		ChokeMin = 2,
		ChokeMax = 6,
		MaxLife = 4,
	};
	const StepDistance = 62;
	double UPitch;
	double UAngle;
	double dista;
	double distb;
	double dist[2];
	//[0] = Current distance travelled
	//[1] = How much further to go
	int choke;
	int count;
	int flags;
	
	Default 
	{
		+NOINTERACTION
		+SEEINVISIBLE
		RenderStyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay
		{
			if (target && tracer)
			{
				Vector3 tpos = (tracer.pos.x, tracer.pos.y, (tracer.pos.z + (tracer.height / 2.0)));
				SetOrigin(tpos, false);
				A_FaceTarget(0,0,0,0,FAF_MIDDLE);
				UPitch = pitch;
				UAngle = angle;
				dista = 0;
				distb = Min(MaxDistance,GetDistance(true,AAPTR_TARGET));
				choke = random(ChokeMin,ChokeMax);
				
				Scale.X = 0.075;
				Scale.Y = 0.5;
			
				if (GetCvar("D4D_BeamTexture"))
				{
					flags = SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERPITCH|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME;
					Scale.X *= 2.5 * randompick(-1,1);
					Scale.Y *= 0.485 * randompick(-1,1);
					return A_Jump(256,1,2,3,4);
				}
				flags = SXF_NOCHECKPOSITION|SXF_TRANSFERSCALE|SXF_TRANSFERPITCH|SXF_TRANSFERPOINTERS;
				return ResolveState("Moving");
			}
			return ResolveState("Null");
		}
	Sprite:
		X206 FGHI 0 A_Jump(256,"Moving");
	Moving:
		"####" "#" 1
		{
			while ((dista < distb) && tracer && tracer.health > 0)
			{
				if (dista > 0)
				{	A_FaceTarget(0,0,0,0,FAF_MIDDLE);	}
				
				if (dista < (distb - StepDistance))
				{
					if (choke > 0)
					{
						pitch += frandom(-PitchRandom, PitchRandom);
						angle += frandom(-AngleRandom, AngleRandom);
						choke--;
					}
					else 
					{	choke = random(ChokeMin,ChokeMax);	}
				}
				
				if (!A_CheckSight("Null") && (dista < distb - (StepDistance / 2.0)))
				{	A_SpawnItemEx("BFGBeamLaser",cos(pitch) * (StepDistance / 2.0),0,-sin(pitch) * (StepDistance / 2.0),0,0,0,0,flags);	}
				
				A_Warp(AAPTR_DEFAULT,cos(pitch) * StepDistance,0,-sin(pitch) * StepDistance,0,WARPF_NOCHECKPOSITION);
				dista += StepDistance;
			}
			if (count < MaxLife)	
			{
				count++;
				return ResolveState(null);
			}
			else
			{	return ResolveState("Null");	}
			
		}
		Goto Spawn;
	}
}

Class BFGBeamLaser : TrailBeam
{
	Default 
	{
		XScale 0.075;
		YScale 0.5; //Don't touch.
		Translation "0:255=%[0,0,0]:[1,2,1]";
	}
	States
	{
	Spawn:
		"####" "#" 0 NoDelay 
		{
			time = 4.0;
			//A_SpawnItemEx("BFGBeamLaser",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME,tid * 256,1);
			
			return A_JumpIf(GetCvar("D4D_BeamTexture"),"Process");
		}
		X202 E 0 	{	Thing_SetTranslation(0,0);	return ResolveState("Process");	}
	}
}

//------------------------------------------------------------------------------
// Gauss Trail
Class GaussTrail : TrailBeam
{
	Default 
	{
		XScale 0.20;
	}
	States
	{
	Spawn:
		X202 B 0 NoDelay
		{
			// time = time to shrink to nothing
			//pitch *= -1;
			time = 17.0;
			//A_SpawnItemEx("GaussTrail",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS,tid * 256,1);
			//if (tid) { angle += 180; }
		}
		Goto Process;
	}
}

Class GaussTrailBig : TrailBeam
{	
	Default 
	{
		XScale 0.30;
	}
	States
	{
	Spawn:
		X202 B 0 NoDelay
		{
			// time = time to shrink to nothing
			//pitch *= -1;
			time = 20.0;
			//A_SpawnItemEx("GaussTrailBig",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS,tid * 256,1);
			//if (tid) { angle += 180; }
		}
		Goto Process;
	}
}

//------------------------------------------------------------------------------
// Static Rifle Trail

Class StaticTrail : TrailBeam
{
	Default 
	{
		XScale 0.1;
		YScale 0.25; //Don't touch.
	}
	States
	{
	Spawn:
		X202 C 0 NoDelay
		{
			//pitch *= -1;
			//if (tid) { angle += 180; }
			// time = time to shrink to nothing
			time = 25.0;
			//A_SpawnItemEx("StaticTrail",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS,tid * 256,1);
		}
		Goto Process;
	}
}

Class StaticTrailBig : StaticTrail
{	Default {	XScale 0.15;	}	}

//------------------------------------------------------------------------------
// ???

Class BigRedLaserDrill : TrailBeamStaticScalingSpawner
{
	bool HQ;
	override void PostBeginPlay()
	{
		Super.PostBeginPlay();
		HQ = GetCvar("HQEffects");
	}
	States
	{
	Spawn:
		X202 J 0 NoDelay
		{
			DoCheckSight = 0;
			DoCheckRange = 0;
			DoCheckFOV = 0;
			MaxDistance = 30000;
			checkrangea = 2048;
			checkfova = 90.0;
			
			A_RearrangePointers(AAPTR_DEFAULT,AAPTR_TARGET,AAPTR_DEFAULT,4);
			A_FaceTracer(0,0,0,0,FAF_MIDDLE);
			
			if (HQ)
			{	A_SpawnItemEx("RedLaserCgunner",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS);	}
			
			// Grab the velocity IMMEDIATELY.
			if (target) { vel = target.vel; }
			
			// The angle and pitch won't change so go ahead and save it now.
			UPitch = pitch;
			UAngle = angle;
			distb = Min(MaxDistance, GetDistance(true,TracerPtr));
			
			// dista = distance currently travelled.
			// distb = maximum distance.
			while ((dista < distb))
			{
				if (DoCheckRange)		{	checkrangeb = (!(A_CheckRange(checkrangea,"Null",false)) ? 1 : 0);	}
				else						{	checkrangeb = 1;	}
				
				if (DoCheckSight)		{	checksight = (!(A_CheckSight("Null")) ? 1 : 0);	}
				else						{	checksight = 1;	}
				
				if (DoCheckFOV)		{	checkfovb = ((abs(GetAngle(GAF_RELATIVE|GAF_SWITCH,AAPTR_PLAYER1)) <= checkfova) ? 1 : 0);	}
				else						{	checkfovb = 1;		}
				
				// Spawn the beam with the same angle and pitch. Note that the
				// beam is being centered so we have to take that into account
				// and spawn it FORWARD based on half the beam's length.
				// Then move forward by a beam's length and repeat until done.
				if (checkrangeb && checksight && checkfovb)
				{	A_SpawnItemEx("BigRedLaserBeamCgunner",cos(pitch) * (StepDistance / 2.0),0,-sin(pitch) * (StepDistance / 2.0),0,0,0,0,SpawnFlags);	}
				A_Warp(AAPTR_DEFAULT,cos(pitch) * StepDistance,0,-sin(pitch) * StepDistance,0,WARPF_NOCHECKPOSITION);
				dista += StepDistance;
			}
		}
		Stop;
	}
}

Class BigRedLaserBeamCgunner : TrailBeamStaticScaling
{
	States
	{
	Spawn:
		TNT1 A 0 NoDelay
		{
			timeup = 10.0;
			wait = 30;
			timedown = 7.0;
			
			// Set this to the actor's same name. The TID will prevent it spawning infinitely (tid * 256).
			A_SpawnItemEx("BigRedLaserBeamCgunner",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS|SXF_TRANSFERSPRITEFRAME,tid * 256,1);
			return ResolveState("Setup");
		}
	}
}

Class RedLaserCgunner : RedLaser
{
	States
	{
	Spawn:
		TNT1 A 0 NoDelay
		{
			count = 45;
			checkrangea = 768;
			DoCheckRange = DoCheckSight = DoCheckFOV = 1;
			
			return ResolveState("Setup");
		}
	}
}

//------------------------------------------------------------------------------
// Carrion ammo
Class CarrionMergeBeam : Actor
{
	enum Carrion
	{
		MaxDistance = 2048,	// Maximum distance of the effect
		AngleRandom = 7,	// The boundaries of angle changing (random(-AngleRandom,AngleRandom))
		PitchRandom = 7,	// ^ for pitch
		ChokeMin = 1,		// How sooner or later the beam needs to correct itself to
		ChokeMax = 5,		// 	"stay on target".
	};
	const StepDistance = 31;
	const StepDistHalf = StepDistance / 2.0;
	double ipitch;
	double iangle;
	double dista;
	double distb;
	Vector3 op;
	//[0] = Current distance travelled
	//[1] = How much further to go
	int choke;
	int t;
	int count;
	int render;
	
	Default
	{
		+NOCLIP
		+NOINTERACTION
		+NOBLOCKMAP
		RenderStyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay
		{
			// The angle and pitch won't change so go ahead and save it now.
			ipitch = pitch;
			iangle = angle;
			distb = Min(MaxDistance, GetDistance(true,TracerPtr));
			choke = random(ChokeMin, ChokeMax);
			op = pos;
			render = int(GetCvar("vid_renderer"));
		}
		TNT1 A 1
		{
			// dista = distance currently travelled.
			// distb = maximum distance.			
			while ((dista < distb))
			{
				if (!tracer)
					return Destroy();
				// Don't randomize the very first beam.
				if (dista > 0)
				{	A_FaceTracer(0,0,0,0,FAF_MIDDLE);	}
				
				// Randomizes the angle of the beams. 
				if (dista < (distb - StepDistance))
				{
					// If we're not about to reach the end, or not hitting the 
					// choker, randomize it. Otherwise, stay on target and go 
					// for the puff.
					if (choke > 0)
					{
						A_SetPitch(pitch + frandom(-PitchRandom, PitchRandom));
						A_SetAngle(angle + frandom(-AngleRandom, AngleRandom));
						choke--;
					}
					else 
					{	choke = random(ChokeMin,ChokeMax);	}
				}
				// Spawn the beam with the same angle and pitch. Note that the
				// beam is being centered so we have to take that into account
				// and spawn it FORWARD based on half the beam's length.
				// Then move forward by a beam's length and repeat until done.
				
				if (render)
				{	A_SpawnItemEx("CarrionTrailBeam",cos(pitch) * StepDistHalf,0,-sin(pitch) * StepDistHalf,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERPOINTERS);	}
				else
				{
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) * (StepDistHalf * (1 / 6)), 0, -sin(pitch) * (StepDistHalf * (1 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) * (StepDistHalf * (2 / 6)), 0, -sin(pitch) * (StepDistHalf * (2 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) * (StepDistHalf * (3 / 6)), 0, -sin(pitch) * (StepDistHalf * (3 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) * (StepDistHalf * (4 / 6)), 0, -sin(pitch) * (StepDistHalf * (4 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) * (StepDistHalf * (5 / 6)), 0, -sin(pitch) * (StepDistHalf * (5 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) * StepDistHalf	 		, 0, -sin(pitch) * (StepDistHalf			 ));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) *-(StepDistHalf * (1 / 6)), 0, -sin(pitch) *-(StepDistHalf * (1 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) *-(StepDistHalf * (2 / 6)), 0, -sin(pitch) *-(StepDistHalf * (2 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) *-(StepDistHalf * (3 / 6)), 0, -sin(pitch) *-(StepDistHalf * (3 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) *-(StepDistHalf * (4 / 6)), 0, -sin(pitch) *-(StepDistHalf * (4 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) *-(StepDistHalf * (5 / 6)), 0, -sin(pitch) *-(StepDistHalf * (5 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) *-StepDistHalf			, 0, -sin(pitch) *-(StepDistHalf			 ));
				}
				
				A_Warp(AAPTR_DEFAULT,cos(pitch) * StepDistance,0,-sin(pitch) * StepDistance,0,WARPF_NOCHECKPOSITION);
				dista += StepDistance;
			}
			
			if (count < 3 && !tracer)
			{
				count++;
				dista = 0;
				pitch = ipitch;
				
				SetOrigin(op, false);
				A_FaceTracer(0,0,0,0,FAF_MIDDLE);
				return;
			}
			return Destroy();
		}
		Wait;
	}
}

Class CarrionShotTrackingLaser : Actor 
{
	enum CarrionShotTrackingLaser
	{
		MaxDistance = 2048,	// Maximum distance of the effect
		AngleRandom = 7,	// The boundaries of angle changing (random(-AngleRandom,AngleRandom))
		PitchRandom = 7,	// ^ for pitch
		ChokeMin = 1,		// How sooner or later the beam needs to correct itself to
		ChokeMax = 5,		// 	"stay on target".
	};
	const StepDistance = 31;
	const StepDistHalf = StepDistance / 2.0;
	double UPitch;
	double UAngle;
	double dista, distb;
	double UX;
	double UY;
	double UZ;
	double angdiff;
	double stepdiv;
	//[0] = Current distance travelled
	//[1] = How much further to go
	int choke;
	int t;
	int count;
	int render;
	PlayerPawn plr;
	Default 
	{
		+NOCLIP
		+NOINTERACTION
		+NOBLOCKMAP
		RenderStyle "None";
	}
	States
	{
	Spawn:
		TNT1 A 1 NoDelay
		{
			// The angle and pitch won't change so go ahead and save it now.
			UPitch = pitch;
			UAngle = angle;
			distb = Min(MaxDistance, GetDistance(true,TracerPtr));
			choke = random(ChokeMin, ChokeMax);
			UX = pos.x;
			UY = pos.y;
			UZ = pos.z;
			render = int(GetCvar("vid_renderer"));
			if (master) 
			{
				plr = PlayerPawn(master);
			}
		}
		TNT1 A 1
		{
			if (!tracer || tracer.CountInv("NoLaser"))
			{	return ResolveState("Null");	}
			
			if (master) { pitch = master.pitch; }
			
			
			
			A_Warp(AAPTR_MASTER,0,7.5,0,0,WARPF_NOCHECKPOSITION|WARPF_STOP,"Null",0.6 + sin(pitch) * 0.2, -0.6 + cos(pitch) * 0.4);
			count = 0;
			angdiff = abs(GetAngle(GAF_RELATIVE,TracerPtr));
			
			if (GetDistance(true,TracerPtr) < StepDistance * 1.5)
			{	return ResolveState(null);	}
			
			// dista = distance currently travelled.
			// distb = maximum distance.
			while ((count < 15) && (GetDistance(false,TracerPtr) > StepDistance * 1.5))
			{
				
				if (A_CheckSight("Null"))
				{	break;	}
				A_FaceTracer(8, 8, 
					frandom(-AngleRandom, AngleRandom), frandom(-PitchRandom, PitchRandom), FAF_MIDDLE);
				
				// Spawn the beam with the same angle and pitch. Note that the
				// beam is being centered so we have to take that into account
				// and spawn it FORWARD based on half the beam's length.
				// Then move forward by a beam's length and repeat until done.
				
				
				if (render)
				{	
					if (CountInv("KillLaser",TracerPtr))
					{	A_SpawnItemEx("CarrionTrailBeamMovingBoom",cos(pitch) * StepDistHalf,0,-sin(pitch) * StepDistHalf,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERPOINTERS);	}
					else
					{	A_SpawnItemEx("CarrionTrailBeamMoving",cos(pitch) * StepDistHalf,0,-sin(pitch) * StepDistHalf,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERPOINTERS);	}
				}
				else
				{
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) * (StepDistHalf * (1 / 6)), 0, -sin(pitch) * (StepDistHalf * (1 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) * (StepDistHalf * (2 / 6)), 0, -sin(pitch) * (StepDistHalf * (2 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) * (StepDistHalf * (3 / 6)), 0, -sin(pitch) * (StepDistHalf * (3 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) * (StepDistHalf * (4 / 6)), 0, -sin(pitch) * (StepDistHalf * (4 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) * (StepDistHalf * (5 / 6)), 0, -sin(pitch) * (StepDistHalf * (5 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) * StepDistHalf	 		, 0, -sin(pitch) * (StepDistHalf			 ));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) *-(StepDistHalf * (1 / 6)), 0, -sin(pitch) *-(StepDistHalf * (1 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) *-(StepDistHalf * (2 / 6)), 0, -sin(pitch) *-(StepDistHalf * (2 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) *-(StepDistHalf * (3 / 6)), 0, -sin(pitch) *-(StepDistHalf * (3 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) *-(StepDistHalf * (4 / 6)), 0, -sin(pitch) *-(StepDistHalf * (4 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) *-(StepDistHalf * (5 / 6)), 0, -sin(pitch) *-(StepDistHalf * (5 / 6)));
					A_SpawnParticle("FF2846",SPF_FULLBRIGHT|SPF_RELATIVE,2,10,0,cos(pitch) *-StepDistHalf			, 0, -sin(pitch) *-(StepDistHalf			 ));
				}
				
				A_Warp(AAPTR_DEFAULT,cos(pitch) * StepDistance,0,-sin(pitch) * StepDistance,0,WARPF_NOCHECKPOSITION);
				dista += StepDistance;
				count = (count + 1) % 8;
			}
			
			if (tracer)
			{
				count = 0;
				dista = 0;
				return ResolveState(null);
			}
			return ResolveState("Null");
		}
		Wait;
	}
}

Class CarrionTrailBeam : TrailBeam
{
	Default
	{
		XScale 0.03;
		YScale 0.25; //Don't touch.
	}
	States
	{
	Spawn:
		X202 I 0 NoDelay
		{
			// time = time to shrink to nothing
			time = 5.0;
			//A_SpawnItemEx("CarrionTrailBeam",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS,tid * 256,1);
			return ResolveState("Process");
		}
	}
}

Class CarrionTrailBeamMoving : MovingTrailBeam
{
	States
	{
	Spawn:
		X202 I 0 NoDelay 
		{
			Zoffset = 0;
			time = 3.0;
			//A_SpawnItemEx("CarrionTrailBeamMoving",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS,tid * 256,1);
			return ResolveState("Process");
		}
	}
}

Class CarrionTrailBeamMovingBoom : MovingTrailBeam
{
	Default 
	{
		RenderStyle "Add";
	}
	
	States
	{
	Spawn:
		X202 J 0 NoDelay 
		{
			Zoffset = 0;
			time = 3.0;
			//A_SpawnItemEx("CarrionTrailBeamMovingBoom",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS,tid * 256,1);
			return ResolveState("Process");
		}
	}
}



Class BulletTrailBeam : TrailBeam
{
	Default 
	{
		XScale 0.05;
		YScale 1; //Don't touch.
	}
	States
	{
	Spawn:
		X202 D 0 NoDelay
		{
			// time = time to shrink to nothing
			time = 4.0;
			//A_SpawnItemEx("BulletTrailBeam",0,0,0,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH|SXF_TRANSFERSCALE|SXF_TRANSFERPOINTERS,tid * 256,1);
			
			return ResolveState("Process");
		}
	}
}

Class BulletTrailBeamInverted : BulletTrailBeam
{
	override void PostBeginPlay()
	{
		pitch *= -1;
		Super.PostBeginPlay();
	}
}

Class BulletTracerFX : Actor 
{
	const Sparsity = 125.0;
	const Distance = 3.25;
	const Multiplier = 1;
	const SpawnSpeed = 300;
	const TravelTic = Sparsity * 30.0;
	enum BulletTracerFX
	{
		ModelOnly = 		1,
		ParticleOnly =		2,
		ParticleTrail =		3,
		TrailOnly =			4,
	};
	int inv;
	int count;
	int rng;
	int render;
	double dista;
	double distb;
	
	virtual void FaceMoveDir()
	{
		A_FaceTracer();
		//A_FaceMovementDirection();
		//pitch *= -1;
		A_ChangeVelocity(cos(pitch), 0, sin(pitch), CVF_RELATIVE|CVF_REPLACE);
	}
	
	Default 
	{
		+NOINTERACTION
		+NOTONAUTOMAP
		+NOTIMEFREEZE
		RenderStyle "None";
		Speed 1;
	}
	States
	{
	Spawn:
		TNT1 A 0 NoDelay 
		{	
			inv = int(GetCvar("D4D_TracerFX"));
			if (A_CheckSight("Null") || !inv)
			{	return ResolveState("Null");	}
			
			if (tracer) A_FaceTracer(0,0);
			//else FaceMoveDir();
			//FaceMoveDir();
			
			else A_FaceMovementDirection();
			if (inv == ModelOnly)
			{	
				A_SpawnItemEx("BulletSmallTracer",0,0,0,vel.x*200,vel.y*200,vel.z*200,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPOINTERS|SXF_ABSOLUTEVELOCITY|SXF_TRANSFERPITCH);
				return ResolveState("Null");	
			}
			
			A_Stop();
			render = int(GetCvar("vid_renderer"));
			count = 1;
			
			if (inv >= TrailOnly)
			{	return ResolveState("B1");	}
			
			A_SpawnParticle("FF8800",SPF_FULLBRIGHT|SPF_RELATIVE,10,4 ,0,cos(pitch)*(Distance*1 ),0,-sin(pitch)*(Distance*1 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FF8F11",SPF_FULLBRIGHT|SPF_RELATIVE,10,5 ,0,cos(pitch)*(Distance*2 ),0,-sin(pitch)*(Distance*2 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FF9822",SPF_FULLBRIGHT|SPF_RELATIVE,10,6 ,0,cos(pitch)*(Distance*3 ),0,-sin(pitch)*(Distance*3 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FF9F33",SPF_FULLBRIGHT|SPF_RELATIVE,10,7 ,0,cos(pitch)*(Distance*4 ),0,-sin(pitch)*(Distance*4 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFA844",SPF_FULLBRIGHT|SPF_RELATIVE,10,8 ,0,cos(pitch)*(Distance*5 ),0,-sin(pitch)*(Distance*5 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFAF55",SPF_FULLBRIGHT|SPF_RELATIVE,10,9 ,0,cos(pitch)*(Distance*6 ),0,-sin(pitch)*(Distance*6 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFB866",SPF_FULLBRIGHT|SPF_RELATIVE,10,10,0,cos(pitch)*(Distance*7 ),0,-sin(pitch)*(Distance*7 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFBF77",SPF_FULLBRIGHT|SPF_RELATIVE,10,10,0,cos(pitch)*(Distance*8 ),0,-sin(pitch)*(Distance*8 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFC888",SPF_FULLBRIGHT|SPF_RELATIVE,10,11,0,cos(pitch)*(Distance*9 ),0,-sin(pitch)*(Distance*9 ),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFCF99",SPF_FULLBRIGHT|SPF_RELATIVE,10,11,0,cos(pitch)*(Distance*10),0,-sin(pitch)*(Distance*10),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFD8AA",SPF_FULLBRIGHT|SPF_RELATIVE,10,12,0,cos(pitch)*(Distance*11),0,-sin(pitch)*(Distance*11),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFDFBB",SPF_FULLBRIGHT|SPF_RELATIVE,10,12,0,cos(pitch)*(Distance*12),0,-sin(pitch)*(Distance*12),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFE8CC",SPF_FULLBRIGHT|SPF_RELATIVE,10,12,0,cos(pitch)*(Distance*13),0,-sin(pitch)*(Distance*13),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFEFDD",SPF_FULLBRIGHT|SPF_RELATIVE,10,13,0,cos(pitch)*(Distance*14),0,-sin(pitch)*(Distance*14),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFF8EE",SPF_FULLBRIGHT|SPF_RELATIVE,10,13,0,cos(pitch)*(Distance*15),0,-sin(pitch)*(Distance*15),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			A_SpawnParticle("FFFFFF",SPF_FULLBRIGHT|SPF_RELATIVE,10,13,0,cos(pitch)*(Distance*16),0,-sin(pitch)*(Distance*16),cos(pitch)*SpawnSpeed,0,-sin(pitch)*SpawnSpeed,0,0,0,1,0);
			
			if (inv == ParticleOnly)
			{	return ResolveState("Null");	}

			if (!IsPointerEqual(TracerPtr,NullPtr))
			{	distb = Clamp(GetDistance(true,TracerPtr),0.0,3000.0);	}
			else
			{	distb = 0;	}
			
			return ResolveState("B1");
		}
	B1:
		TNT1 A 1;
	Break:
		TNT1 A 1 
		{
			if (count > 14 || A_CheckSight("Null") || (pos.z < floorz) || (pos.z > ceilingz) ) 
			{	return ResolveState("Null");	} // Destroy it.
			dista = 0;
			return ResolveState(null); //Play out the tic.
		}
	Looping:	// Spawns the trail.
		TNT1 A 0
		{
			// If running GZDoom, spawn the neat trail.
			if (render)
			{
				if (dista <= 0.0)
				{	dista = 64.0;	}
				A_SpawnItemEx("BulletTrailBeam",cos(pitch)*dista,0,-sin(pitch)*dista,0,0,0,0,SXF_NOCHECKPOSITION|SXF_TRANSFERPITCH);
				dista += Sparsity;
			}
			else //Otherwise, do the ol' fashion particles.
			{
				A_SpawnParticle("FFE99E",SPF_FULLBRIGHT|SPF_RELATIVE,100,random(3,6),0,
					cos(pitch)*dista,0,-sin(pitch)*dista,
					frandom(1.0,2.0),0,0,
					-0.005,0,0.005,
					frandom(0.5,1.0),frandom(0.06,0.12));
				
				dista += frandom(3.0,6.0);
			}
			
			if (distb > 0.0)
			{
				if (dista > distb)
				{	return ResolveState("Null");	}
				return ResolveState("Looping");
			}
			else if (dista >= TravelTic)
			{
				count++;
				A_Warp(AAPTR_DEFAULT,cos(pitch)*TravelTic,0,-sin(pitch)*TravelTic,0,WARPF_NOCHECKPOSITION);
				return ResolveState("Break");
			}
			return ResolveState("Looping");
		}
		Loop;
	End:
		TNT1 A 0;
		Stop;
	}
}

Class BulletTracerFXInverted : BulletTracerFX
{}

//==============================================================================
// ZDoom BFG Beam
Class BFGBeam : Actor 
{
	const Limit = 18.0;
	const FMin = 0.5;
	const FMax = 1.0;
	double UXa, UXb;
	double UYa, UYb;
	double UZa, UZb;
	double dist;
	int life;
	int count;
	int minicount;
	double  scalar;
	Default 
	{
		+NOINTERACTION
		+NOBLOCKMAP
		+NOTONAUTOMAP
		RenderStyle "None";
		Speed 5;
	}
	States
	{
	Spawn:
		TNT1 A 1 NoDelay
		{
			if (life >= 2 || !tracer || tracer.bKILLED)
			{	return ResolveState("Null");	}
			
			if (target)
			{
				life++;
				count = minicount = 0;
				scalar = 0;
				
				Vector3 tpos = tracer.pos;	tpos.z += tracer.height / 2.0;
				SetOrigin(tpos, false);
				A_FaceTarget(0,0,0,0,FAF_MIDDLE);
				dist = GetDistance(true, AAPTR_TARGET);
				return ResolveState("Beam");
			}
			return ResolveState("Null");
		}
		Stop;
	Beam:
		TNT1 A 2
		{
			if (count >= dist)
			{	return ResolveState(null);	}
			
			if (count < (speed * 20))
			{	scalar = Clamp(scalar + (1.0/20.0), 0.0, 1.0);	}
			if (count >= (dist - (speed * 20)))
			{	scalar = Clamp(scalar - (1.0/20.0), 0.0, 1.0);	}
			
			if (minicount <= 0)
			{
				UXb = frandom(FMin,FMax) * randompick(-1,1);
				UYb = frandom(FMin,FMax) * randompick(-1,1);
				UZb = frandom(FMin,FMax) * randompick(-1,1);
				minicount = random(2,4);
			}
			else
			{
			
				UXa += UXb;
				UYa += UYb;
				UZa += UZb;
				minicount--;
			}
			if (UYa > Limit)		{	UYa -= ((abs(UYa) % Limit) * 2);	}
			if (UYa < -Limit)		{	UYa += ((abs(UYa) % Limit) * 2);	}
			
			if (UZa > Limit)		{	UZa -= ((abs(UZa) % Limit) * 2);	}
			if (UZa < -Limit)		{	UZa += ((abs(UZa) % Limit) * 2);	}
			
			A_SpawnParticle("A7FF47",SPF_FULLBRIGHT|SPF_RELATIVE,3,16,0,
				(cos(pitch)*count)-(sin(pitch)*UXa*scalar),
				UYa*scalar,
				((sin(pitch)*count)+(cos(pitch)*UZa*scalar)),
				0,0,0,0,0,0,1.0,0.3);
				
			count += int(speed);
			return ResolveState("Beam");
		}
		Goto Spawn;
	}
}